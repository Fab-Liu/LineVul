{
    "valid.c": {
        "xmlValidateElementContent": {
            "code": "xmlValidateElementContent(xmlValidCtxtPtr ctxt, xmlNodePtr child,\nif ((elemDecl == NULL) || (parent == NULL) || (ctxt == NULL))\nreturn(-1);\ncont = elemDecl->content;\nret = xmlValidBuildContentModel(ctxt, elemDecl);\nif (elemDecl->contModel == NULL) {\nreturn(-1);\nxmlRegExecCtxtPtr exec;\nreturn(-1);\nctxt->nodeMax = 0;\ncur = child;\nwhile (cur != NULL) {\nswitch (cur->type) {\nif ((cur->children != NULL) &&\n(cur->children->children != NULL)) {\nnodeVPush(ctxt, cur);\nbreak;\nif (xmlIsBlankNode(cur))\nbreak;\nret = 0;\nret = 0;\nif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\nxmlChar fn[50];\nret = -1;\nret = xmlRegExecPushString(exec, fullname, NULL);\nif ((fullname != fn) && (fullname != cur->name))\nxmlFree(fullname);\n} else {\nret = xmlRegExecPushString(exec, cur->name, NULL);\nbreak;\nbreak;\ncur = cur->next;\nwhile (cur == NULL) {\ncur = nodeVPop(ctxt);\nbreak;\ncur = cur->next;\nret = xmlRegExecPushString(exec, NULL, NULL);\nxmlRegFreeExecCtxt(exec);\nif ((warn) && ((ret != 1) && (ret != -3))) {\nif (ctxt != NULL) {\nchar expr[5000];\nxmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\nxmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n} else {\nif (name != NULL) {\nxmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\nxmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\nret = 0;\nif (ret == -3)\nret = 1;\nctxt->nodeMax = 0;\nxmlFree(ctxt->nodeTab);\nreturn(ret);", 
            "lines": [
                5230, 
                5240, 
                5241, 
                5242, 
                5248, 
                5249, 
                5250, 
                5252, 
                5255, 
                5257, 
                5262, 
                5263, 
                5264, 
                5270, 
                5271, 
                5272, 
                5276, 
                5278, 
                5279, 
                5280, 
                5284, 
                5287, 
                5288, 
                5294, 
                5297, 
                5298, 
                5299, 
                5300, 
                5301, 
                5303, 
                5305, 
                5310, 
                5311, 
                5312, 
                5314, 
                5315, 
                5318, 
                5320, 
                5439, 
                5440, 
                5441, 
                5455, 
                5459, 
                5463, 
                5464, 
                5465, 
                5469, 
                5474, 
                5476, 
                5477, 
                5495, 
                5498, 
                5501
            ]
        }, 
        "xmlAddRef": {
            "code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\nreturn(NULL);\nif (value == NULL) {\nreturn(NULL);\nif (attr == NULL) {\nreturn(NULL);\ntable = (xmlRefTablePtr) doc->refs;\ndoc->refs = table = xmlHashCreateDict(0, doc->dict);\nif (table == NULL) {\nxmlVErrMemory(ctxt,\nret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\nxmlVErrMemory(ctxt, \"malloc failed\");\nret->value = xmlStrdup(value);\nif ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\nret->name = xmlStrdup(attr->name);\nret->name = NULL;\nret->lineno = xmlGetLineNo(attr->parent);\nif (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nif (xmlHashAddEntry(table, value, ref_list) < 0) {\nxmlListDelete(ref_list);\n}\nif (xmlListAppend(ref_list, ret) != 0) {\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nreturn(ret);\nif (ret != NULL) {\nif (ret->value != NULL)\nxmlFree((char *)ret->value);\nif (ret->name != NULL)\nxmlFree((char *)ret->name);\nxmlFree(ret);\nreturn(NULL);", 
            "lines": [
                2900, 
                2907, 
                2909, 
                2910, 
                2912, 
                2913, 
                2919, 
                2921, 
                2923, 
                2924, 
                2929, 
                2931, 
                2938, 
                2939, 
                2943, 
                2946, 
                2949, 
                2959, 
                2960, 
                2965, 
                2966, 
                2972, 
                2973, 
                2974, 
                2979, 
                2981, 
                2982, 
                2983, 
                2984, 
                2985, 
                2986, 
                2988
            ]
        }, 
        "xmlValidateNotationUse": {
            "code": "xmlValidateNotationUse(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nif ((doc == NULL) || (doc->intSubset == NULL) ||\n(notationName == NULL)) return(-1);\nnotaDecl = xmlGetDtdNotationDesc(doc->intSubset, notationName);\nif ((notaDecl == NULL) && (doc->extSubset != NULL))\nnotaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\nif ((notaDecl == NULL) && (ctxt != NULL)) {\nxmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\nreturn(1);", 
            "lines": [
                3352, 
                3355, 
                3356, 
                3358, 
                3359, 
                3360, 
                3362, 
                3363, 
                3368
            ]
        }, 
        "xmlValidGetValidElements": {
            "code": "xmlValidGetValidElements(xmlNode *prev, xmlNode *next, const xmlChar **names,\nif (prev == NULL && next == NULL)\nreturn(-1);\nif (names == NULL) return(-1);\nif (max <= 0) return(-1);\nmemset(&vctxt, 0, sizeof (xmlValidCtxt));\nref_node = prev ? prev : next;\nif ((element_desc == NULL) && (parent->doc->extSubset != NULL))\nelement_desc = xmlGetDtdElementDesc(parent->doc->extSubset,\nif (element_desc == NULL) return(-1);\nprev_next = prev ? prev->next : NULL;\nnext_prev = next ? next->prev : NULL;\nreturn(-1);\ntest_node->parent = parent;\nif (prev) prev->next = test_node;\nelse parent->children = test_node;\nif (next) next->prev = test_node;\nelse parent->last = test_node;\nnb_elements = xmlValidGetPotentialChildren(element_desc->content,\nfor (i = 0;i < nb_elements;i++) {\ntest_node->name = elements[i];\nint j;\nfor (j = 0; j < nb_valid_elements;j++)\nif (xmlStrEqual(elements[i], names[j])) break;\nnames[nb_valid_elements++] = elements[i];\nif (nb_valid_elements >= max) break;\n}\n}\nif (prev) prev->next = prev_next;\nif (next) next->prev = next_prev;\nparent->children = parent_childs;", 
            "lines": [
                6948, 
                6967, 
                6968, 
                6970, 
                6971, 
                6973, 
                6977, 
                6985, 
                6986, 
                6988, 
                6993, 
                6994, 
                7003, 
                7005, 
                7010, 
                7011, 
                7013, 
                7014, 
                7020, 
                7023, 
                7024, 
                7026, 
                7028, 
                7029, 
                7030, 
                7031, 
                7032, 
                7033, 
                7038, 
                7039, 
                7040
            ]
        }, 
        "xmlFreeValidCtxt": {
            "code": "xmlFreeValidCtxt(xmlValidCtxtPtr cur) {\nxmlFree(cur->vstateTab);\nif (cur->nodeTab != NULL)\nxmlFree(cur->nodeTab);", 
            "lines": [
                900, 
                902, 
                903, 
                904
            ]
        }, 
        "xmlFreeNotation": {
            "code": "xmlFreeNotation(xmlNotationPtr nota) {\nif (nota == NULL) return;\nif (nota->name != NULL)\nxmlFree((xmlChar *) nota->name);\nif (nota->PublicID != NULL)\nxmlFree((xmlChar *) nota->PublicID);\nif (nota->SystemID != NULL)\nxmlFree((xmlChar *) nota->SystemID);\nxmlFree(nota);", 
            "lines": [
                2322, 
                2323, 
                2324, 
                2325, 
                2326, 
                2327, 
                2328, 
                2329, 
                2330
            ]
        }, 
        "xmlValidateElement": {
            "code": "xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem) {\nif (elem == NULL) return(0);\nif ((elem->type == XML_XINCLUDE_START) ||\n(elem->type == XML_XINCLUDE_END) ||\n(elem->type == XML_NAMESPACE_DECL))\nreturn(1);\nCHECK_DTD;\nif (elem->type == XML_ENTITY_REF_NODE) {\nreturn(1);\nret &= xmlValidateOneElement(ctxt, doc, elem);\nattr = elem->properties;\nwhile (attr != NULL) {\nvalue = xmlNodeListGetString(doc, attr->children, 0);\nxmlFree((char *)value);\nattr= attr->next;\nns = elem->nsDef;\nwhile (ns != NULL) {\nif (elem->ns == NULL)\nret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\nret &= xmlValidateOneNamespace(ctxt, doc, elem,\nns = ns->next;\n}\nchild = elem->children;\nwhile (child != NULL) {\nret &= xmlValidateElement(ctxt, doc, child);\nreturn(ret);", 
            "lines": [
                6370, 
                6377, 
                6383, 
                6384, 
                6385, 
                6386, 
                6388, 
                6393, 
                6394, 
                6397, 
                6399, 
                6400, 
                6401, 
                6404, 
                6405, 
                6407, 
                6408, 
                6409, 
                6410, 
                6413, 
                6415, 
                6417, 
                6418, 
                6419, 
                6420, 
                6424
            ]
        }, 
        "xmlDumpElementContent": {
            "code": "xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {\nif (content == NULL) return;\nif (glob) xmlBufferWriteChar(buf, \"(\");\nswitch (content->type) {\nxmlBufferWriteChar(buf, \"#PCDATA\");\nif (content->prefix != NULL) {\nxmlBufferWriteCHAR(buf, content->prefix);\nxmlBufferWriteCHAR(buf, content->name);\nif ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n(content->c1->type == XML_ELEMENT_CONTENT_SEQ))\nxmlDumpElementContent(buf, content->c1, 1);\nxmlDumpElementContent(buf, content->c1, 0);\nxmlBufferWriteChar(buf, \" , \");\n((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&\n(content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))\nxmlDumpElementContent(buf, content->c2, 1);\nxmlDumpElementContent(buf, content->c2, 0);\nbreak;\nif ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n(content->c1->type == XML_ELEMENT_CONTENT_SEQ))\nxmlDumpElementContent(buf, content->c1, 1);\nxmlDumpElementContent(buf, content->c1, 0);\nxmlBufferWriteChar(buf, \" | \");\n((content->c2->type == XML_ELEMENT_CONTENT_OR) &&\n(content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))\nxmlDumpElementContent(buf, content->c2, 1);\nxmlDumpElementContent(buf, content->c2, 0);\nbreak;\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nif (glob)\nxmlBufferWriteChar(buf, \")\");\nswitch (content->ocur) {\nbreak;\nxmlBufferWriteChar(buf, \"?\");\nxmlBufferWriteChar(buf, \"*\");\nxmlBufferWriteChar(buf, \"+\");", 
            "lines": [
                1159, 
                1160, 
                1162, 
                1163, 
                1165, 
                1168, 
                1169, 
                1172, 
                1175, 
                1176, 
                1177, 
                1179, 
                1180, 
                1182, 
                1183, 
                1184, 
                1186, 
                1187, 
                1189, 
                1190, 
                1191, 
                1193, 
                1194, 
                1196, 
                1197, 
                1198, 
                1200, 
                1201, 
                1203, 
                1207, 
                1208, 
                1209, 
                1211, 
                1213, 
                1216, 
                1219
            ]
        }, 
        "xmlIsDocNameStartChar": {
            "code": "xmlIsDocNameStartChar(xmlDocPtr doc, int c) {\nif ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\nif (((c >= 'a') && (c <= 'z')) ||\n((c >= 'A') && (c <= 'Z')) ||\n(c == '_') || (c == ':') ||\n((c >= 0xC0) && (c <= 0xD6)) ||\n((c >= 0xD8) && (c <= 0xF6)) ||\n((c >= 0xF8) && (c <= 0x2FF)) ||\n((c >= 0x370) && (c <= 0x37D)) ||\n((c >= 0x37F) && (c <= 0x1FFF)) ||\n((c >= 0x200C) && (c <= 0x200D)) ||\n((c >= 0x2070) && (c <= 0x218F)) ||\n((c >= 0x2C00) && (c <= 0x2FEF)) ||\n((c >= 0x3001) && (c <= 0xD7FF)) ||\n((c >= 0xF900) && (c <= 0xFDCF)) ||\n((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n((c >= 0x10000) && (c <= 0xEFFFF)))\nreturn(1);\n} else {\nif (IS_LETTER(c) || (c == '_') || (c == ':'))\nreturn(1);\nreturn(0);", 
            "lines": [
                3413, 
                3414, 
                3419, 
                3420, 
                3421, 
                3422, 
                3423, 
                3424, 
                3425, 
                3426, 
                3427, 
                3428, 
                3429, 
                3430, 
                3431, 
                3432, 
                3433, 
                3434, 
                3435, 
                3436, 
                3437, 
                3439
            ]
        }, 
        "xmlDumpElementTable": {
            "code": "xmlDumpElementTable(xmlBufferPtr buf, xmlElementTablePtr table) {\nif ((buf == NULL) || (table == NULL))\nreturn;\nxmlHashScan(table, (xmlHashScanner) xmlDumpElementDeclScan, buf);", 
            "lines": [
                1737, 
                1738, 
                1739, 
                1740
            ]
        }, 
        "xmlValidateNotationCallback": {
            "code": "xmlValidateNotationCallback(xmlEntityPtr cur, xmlValidCtxtPtr ctxt,\nreturn;\nif (cur->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\nxmlChar *notation = cur->content;\nint ret;\nctxt->valid = 0;\n}\n}", 
            "lines": [
                6648, 
                6651, 
                6652, 
                6653, 
                6656, 
                6660, 
                6662, 
                6663
            ]
        }, 
        "xmlFreeAttribute": {
            "code": "xmlFreeAttribute(xmlAttributePtr attr) {\nif (attr == NULL) return;\nif (attr->doc != NULL)\ndict = attr->doc->dict;\ndict = NULL;\nxmlUnlinkNode((xmlNodePtr) attr);\nxmlFreeEnumeration(attr->tree);\nif (dict) {\nif ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))\nxmlFree((xmlChar *) attr->elem);\nif ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))\nxmlFree((xmlChar *) attr->name);\nif ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))\nxmlFree((xmlChar *) attr->prefix);\nif ((attr->defaultValue != NULL) &&\n(!xmlDictOwns(dict, attr->defaultValue)))\nxmlFree((xmlChar *) attr->defaultValue);\n} else {\nif (attr->elem != NULL)\nxmlFree((xmlChar *) attr->elem);\nif (attr->name != NULL)\nxmlFree((xmlChar *) attr->name);\nif (attr->defaultValue != NULL)\nxmlFree((xmlChar *) attr->defaultValue);\nif (attr->prefix != NULL)\nxmlFree((xmlChar *) attr->prefix);\nxmlFree(attr);", 
            "lines": [
                1873, 
                1876, 
                1877, 
                1878, 
                1880, 
                1881, 
                1883, 
                1884, 
                1885, 
                1886, 
                1887, 
                1888, 
                1889, 
                1890, 
                1891, 
                1892, 
                1893, 
                1894, 
                1895, 
                1896, 
                1897, 
                1898, 
                1899, 
                1900, 
                1901, 
                1902, 
                1904
            ]
        }, 
        "xmlCopyAttribute": {
            "code": "xmlCopyAttribute(xmlAttributePtr attr) {\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(cur, 0, sizeof(xmlAttribute));\ncur->elem = xmlStrdup(attr->elem);\nif (attr->name != NULL)\ncur->name = xmlStrdup(attr->name);\nif (attr->prefix != NULL)\ncur->prefix = xmlStrdup(attr->prefix);\nif (attr->defaultValue != NULL)\ncur->defaultValue = xmlStrdup(attr->defaultValue);\nreturn(cur);", 
            "lines": [
                2161, 
                2166, 
                2169, 
                2175, 
                2176, 
                2177, 
                2178, 
                2179, 
                2180, 
                2181, 
                2182
            ]
        }, 
        "xmlValidateOneAttribute": {
            "code": "xmlValidateOneAttribute(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nCHECK_DTD;\nif ((elem == NULL) || (elem->name == NULL)) return(0);\nif ((attr == NULL) || (attr->name == NULL)) return(0);\nif ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\nxmlChar fn[50];\nreturn(0);\nif (attr->ns != NULL) {\nattrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n} else {\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\nif ((fullname != fn) && (fullname != elem->name))\nxmlFree(fullname);\n}\nif (attrDecl == NULL) {\nif (attr->ns != NULL) {\nattrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n} else {\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n}\nif (attrDecl == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\nattr->atype = attrDecl->atype;\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\nif (attrDecl->def == XML_ATTRIBUTE_FIXED) {\nif (!xmlStrEqual(value, attrDecl->defaultValue)) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n}\nif (attrDecl->atype == XML_ATTRIBUTE_ID) {\nif (xmlAddID(ctxt, doc, value, attr) == NULL)\nret = 0;\n}\nif ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\nif (xmlAddRef(ctxt, doc, value, attr) == NULL)\nret = 0;\n}\nif (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\nxmlEnumerationPtr tree = attrDecl->tree;\nnota = xmlGetDtdNotationDesc(doc->extSubset, value);\nif (nota == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\nwhile (tree != NULL) {\nif (xmlStrEqual(tree->name, value)) break;\ntree = tree->next;\nif (tree == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n}\nif (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\nxmlEnumerationPtr tree = attrDecl->tree;\nwhile (tree != NULL) {\nif (xmlStrEqual(tree->name, value)) break;\ntree = tree->next;\nif (tree == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n}\nif ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n(!xmlStrEqual(attrDecl->defaultValue, value))) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\nret &= xmlValidateAttributeValue2(ctxt, doc, attr->name,", 
            "lines": [
                4350, 
                4357, 
                4358, 
                4359, 
                4361, 
                4362, 
                4367, 
                4368, 
                4369, 
                4371, 
                4372, 
                4374, 
                4375, 
                4376, 
                4377, 
                4380, 
                4381, 
                4382, 
                4383, 
                4384, 
                4385, 
                4387, 
                4388, 
                4390, 
                4391, 
                4393, 
                4394, 
                4397, 
                4401, 
                4402, 
                4407, 
                4411, 
                4418, 
                4419, 
                4420, 
                4425, 
                4428, 
                4429, 
                4430, 
                4431, 
                4433, 
                4434, 
                4435, 
                4436, 
                4437, 
                4440, 
                4441, 
                4447, 
                4449, 
                4450, 
                4457, 
                4458, 
                4459, 
                4461, 
                4462, 
                4467, 
                4470, 
                4471, 
                4472, 
                4473, 
                4474, 
                4476, 
                4477, 
                4482, 
                4485, 
                4486, 
                4487, 
                4494
            ]
        }, 
        "xmlValidateNameValueInternal": {
            "code": "xmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {\nif (value == NULL) return(0);\ncur = value;\nreturn(0);\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (val != 0) return(0);\nreturn(1);", 
            "lines": [
                3491, 
                3495, 
                3496, 
                3500, 
                3502, 
                3504, 
                3505, 
                3509, 
                3511
            ]
        }, 
        "xmlGetDtdAttrDesc": {
            "code": "xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {\nif (dtd == NULL) return(NULL);\nif (dtd->attributes == NULL) return(NULL);\ntable = (xmlAttributeTablePtr) dtd->attributes;\nreturn(NULL);\nuqname = xmlSplitQName2(name, &prefix);\ncur = xmlHashLookup3(table, uqname, prefix, elem);\nif (prefix != NULL) xmlFree(prefix);\nif (uqname != NULL) xmlFree(uqname);\n} else\ncur = xmlHashLookup3(table, name, NULL, elem);\nreturn(cur);", 
            "lines": [
                3269, 
                3274, 
                3275, 
                3277, 
                3279, 
                3281, 
                3284, 
                3285, 
                3286, 
                3287, 
                3288, 
                3289
            ]
        }, 
        "xmlIsDocNameChar": {
            "code": "xmlIsDocNameChar(xmlDocPtr doc, int c) {\nif ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\nif (((c >= 'a') && (c <= 'z')) ||\n((c >= 'A') && (c <= 'Z')) ||\n((c >= '0') && (c <= '9')) || /* !start */\n(c == '_') || (c == ':') ||\n(c == '-') || (c == '.') || (c == 0xB7) || /* !start */\n((c >= 0xC0) && (c <= 0xD6)) ||\n((c >= 0xD8) && (c <= 0xF6)) ||\n((c >= 0xF8) && (c <= 0x2FF)) ||\n((c >= 0x300) && (c <= 0x36F)) || /* !start */\n((c >= 0x370) && (c <= 0x37D)) ||\n((c >= 0x37F) && (c <= 0x1FFF)) ||\n((c >= 0x200C) && (c <= 0x200D)) ||\n((c >= 0x203F) && (c <= 0x2040)) || /* !start */\n((c >= 0x2070) && (c <= 0x218F)) ||\n((c >= 0x2C00) && (c <= 0x2FEF)) ||\n((c >= 0x3001) && (c <= 0xD7FF)) ||\n((c >= 0xF900) && (c <= 0xFDCF)) ||\n((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n((c >= 0x10000) && (c <= 0xEFFFF)))\nreturn(1);\n} else {\nif ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n(c == '.') || (c == '-') ||\n(c == '_') || (c == ':') ||\n(IS_COMBINING(c)) ||\n(IS_EXTENDER(c)))\nreturn(1);\nreturn(0);", 
            "lines": [
                3443, 
                3444, 
                3449, 
                3450, 
                3451, 
                3452, 
                3453, 
                3454, 
                3455, 
                3456, 
                3457, 
                3458, 
                3459, 
                3460, 
                3461, 
                3462, 
                3463, 
                3464, 
                3465, 
                3466, 
                3467, 
                3468, 
                3469, 
                3470, 
                3471, 
                3472, 
                3473, 
                3474, 
                3475, 
                3477
            ]
        }, 
        "xmlVErrMemory": {
            "code": "xmlVErrMemory(xmlValidCtxtPtr ctxt, const char *extra)\nchannel = ctxt->error;\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\nlong delta = (char *) ctxt - (char *) ctxt->userData;\nif ((delta > 0) && (delta < 250))\npctxt = ctxt->userData;\n}\n}\nif (extra)\n__xmlRaiseError(NULL, channel, data,\n__xmlRaiseError(NULL, channel, data,", 
            "lines": [
                58, 
                65, 
                70, 
                71, 
                72, 
                73, 
                74, 
                75, 
                76, 
                77, 
                82
            ]
        }, 
        "xmlFreeRef": {
            "code": "xmlFreeRef(xmlLinkPtr lk) {\nif (ref == NULL) return;\nif (ref->value != NULL)\nxmlFree((xmlChar *)ref->value);\nif (ref->name != NULL)\nxmlFree((xmlChar *)ref->name);\nxmlFree(ref);", 
            "lines": [
                2831, 
                2833, 
                2834, 
                2835, 
                2836, 
                2837, 
                2838
            ]
        }, 
        "xmlFreeEnumeration": {
            "code": "xmlFreeEnumeration(xmlEnumerationPtr cur) {\nif (cur == NULL) return;\nif (cur->next != NULL) xmlFreeEnumeration(cur->next);\nif (cur->name != NULL) xmlFree((xmlChar *) cur->name);\nxmlFree(cur);", 
            "lines": [
                1776, 
                1777, 
                1779, 
                1781, 
                1782
            ]
        }, 
        "xmlValidateNamesValueInternal": {
            "code": "xmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {\nif (value == NULL) return(0);\ncur = value;\nreturn(0);\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (val == 0x20) {\nwhile (val == 0x20) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (!xmlIsDocNameStartChar(doc, val))\nreturn(0);\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (val != 0) return(0);\nreturn(1);", 
            "lines": [
                3539, 
                3543, 
                3544, 
                3549, 
                3551, 
                3553, 
                3554, 
                3559, 
                3560, 
                3561, 
                3565, 
                3566, 
                3568, 
                3571, 
                3572, 
                3577, 
                3579
            ]
        }, 
        "xmlValidateRoot": {
            "code": "xmlValidateRoot(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\nif (doc == NULL) return(0);\nroot = xmlDocGetRootElement(doc);\nif ((root == NULL) || (root->name == NULL)) {\nxmlErrValid(ctxt, XML_DTD_NO_ROOT,\nif ((doc->intSubset != NULL) &&\n(doc->intSubset->name != NULL)) {\nif (!xmlStrEqual(doc->intSubset->name, root->name)) {\nif ((root->ns != NULL) && (root->ns->prefix != NULL)) {\nxmlChar fn[50];\nxmlVErrMemory(ctxt, NULL);\nret = xmlStrEqual(doc->intSubset->name, fullname);\nif ((fullname != fn) && (fullname != root->name))\nxmlFree(fullname);\nif (ret == 1)\ngoto name_ok;\n}\nif ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n(xmlStrEqual(root->name, BAD_CAST \"html\")))\ngoto name_ok;\nxmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n}\nreturn(1);", 
            "lines": [
                6306, 
                6310, 
                6312, 
                6313, 
                6314, 
                6323, 
                6324, 
                6328, 
                6329, 
                6330, 
                6335, 
                6338, 
                6339, 
                6340, 
                6341, 
                6342, 
                6343, 
                6344, 
                6345, 
                6346, 
                6347, 
                6352, 
                6354
            ]
        }, 
        "xmlSnprintfElementContent": {
            "code": "xmlSnprintfElementContent(char *buf, int size, xmlElementContentPtr content, int englob) {\nif (content == NULL) return;\nlen = strlen(buf);\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nif (englob) strcat(buf, \"(\");\nswitch (content->type) {\nstrcat(buf, \"#PCDATA\");\nif (content->prefix != NULL) {\nif (size - len < xmlStrlen(content->prefix) + 10) {\nstrcat(buf, \" ...\");\nstrcat(buf, (char *) content->prefix);\nif (size - len < xmlStrlen(content->name) + 10) {\nstrcat(buf, \" ...\");\nif (content->name != NULL)\nstrcat(buf, (char *) content->name);\nbreak;\nif ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n(content->c1->type == XML_ELEMENT_CONTENT_SEQ))\nxmlSnprintfElementContent(buf, size, content->c1, 1);\nxmlSnprintfElementContent(buf, size, content->c1, 0);\nlen = strlen(buf);\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nstrcat(buf, \" , \");\n(content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\nxmlSnprintfElementContent(buf, size, content->c2, 1);\nxmlSnprintfElementContent(buf, size, content->c2, 0);\nbreak;\nif ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n(content->c1->type == XML_ELEMENT_CONTENT_SEQ))\nxmlSnprintfElementContent(buf, size, content->c1, 1);\nxmlSnprintfElementContent(buf, size, content->c1, 0);\nlen = strlen(buf);\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nstrcat(buf, \" | \");\n(content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\nxmlSnprintfElementContent(buf, size, content->c2, 1);\nxmlSnprintfElementContent(buf, size, content->c2, 0);\nbreak;\nif (englob)\nstrcat(buf, \")\");\nswitch (content->ocur) {\nbreak;\nstrcat(buf, \"?\");\nstrcat(buf, \"*\");\nstrcat(buf, \"+\");", 
            "lines": [
                1250, 
                1253, 
                1254, 
                1256, 
                1257, 
                1258, 
                1260, 
                1261, 
                1263, 
                1266, 
                1267, 
                1268, 
                1271, 
                1274, 
                1275, 
                1278, 
                1279, 
                1280, 
                1282, 
                1283, 
                1284, 
                1286, 
                1287, 
                1289, 
                1290, 
                1291, 
                1293, 
                1295, 
                1296, 
                1297, 
                1299, 
                1300, 
                1302, 
                1303, 
                1304, 
                1306, 
                1307, 
                1309, 
                1310, 
                1311, 
                1313, 
                1315, 
                1316, 
                1317, 
                1319, 
                1320, 
                1322, 
                1323, 
                1324, 
                1326, 
                1328, 
                1331, 
                1334
            ]
        }, 
        "xmlValidatePushCData": {
            "code": "xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {\nreturn(0);\nif (len <= 0)\nreturn(ret);\nif ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\nxmlValidStatePtr state = ctxt->vstate;\nelemDecl = state->elemDecl;\nret = 0;\nxmlErrValidNode(ctxt, state->node,\nbreak;\nbreak;\nif (len > 0) {\nint i;\nfor (i = 0;i < len;i++) {\nif (!IS_BLANK_CH(data[i])) {\nxmlErrValidNode(ctxt, state->node,\n}\n}\nbreak;\n}\n}\nreturn(ret);", 
            "lines": [
                5807, 
                5812, 
                5813, 
                5814, 
                5815, 
                5816, 
                5823, 
                5827, 
                5830, 
                5837, 
                5839, 
                5841, 
                5842, 
                5844, 
                5845, 
                5846, 
                5853, 
                5860, 
                5861, 
                5863, 
                5864, 
                5866
            ]
        }, 
        "xmlValidateOneElement": {
            "code": "xmlValidateOneElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nCHECK_DTD;\nif (elem == NULL) return(0);\nswitch (elem->type) {\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nif (elem->children != NULL) {\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nif (elem->ns != NULL) {\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nif (elem->content == NULL) {\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nreturn(1);\nreturn(1);\nreturn(1);\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nbreak;\nxmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\nelemDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);\nreturn(0);\nif (ctxt->vstateNr == 0) {\nswitch (elemDecl->etype) {\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\nif (elem->children != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\nbreak;\nbreak;\nif ((elemDecl->content != NULL) &&\n(elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\nret = xmlValidateOneCdataElement(ctxt, doc, elem);\nxmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\nbreak;\nchild = elem->children;\nwhile (child != NULL) {\nif (child->type == XML_ELEMENT_NODE) {\nname = child->name;\nif ((child->ns != NULL) && (child->ns->prefix != NULL)) {\nxmlChar fn[50];\nreturn(0);\ncont = elemDecl->content;\nwhile (cont != NULL) {\nif (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\nif (xmlStrEqual(cont->name, fullname))\nbreak;\n} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n(cont->c1 != NULL) &&\n(cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\nif (xmlStrEqual(cont->c1->name, fullname))\nbreak;\n} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n(cont->c1 == NULL) ||\n(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\nxmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\ncont = cont->c2;\nif ((fullname != fn) && (fullname != child->name))\nxmlFree(fullname);\nif (cont != NULL)\ngoto child_ok;\n}\ncont = elemDecl->content;\nwhile (cont != NULL) {\nif (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\nif (xmlStrEqual(cont->name, name)) break;\n} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n(cont->c1 != NULL) &&\n(cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\nif (xmlStrEqual(cont->c1->name, name)) break;\n} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n(cont->c1 == NULL) ||\n(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\nxmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\ncont = cont->c2;\nif (cont == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n}\nchild = child->next;\nbreak;\nif ((doc->standalone == 1) && (extsubset == 1)) {\nchild = elem->children;\nwhile (child != NULL) {\nif (child->type == XML_TEXT_NODE) {\nconst xmlChar *content = child->content;\nwhile (IS_BLANK_CH(*content))\ncontent++;\nif (*content == 0) {\nxmlErrValidNode(ctxt, elem,\n}\nchild =child->next;\n}\nchild = elem->children;\nret = tmp;\nbreak;\n} /* not continuous */\nattr = elemDecl->attributes;\nwhile (attr != NULL) {\nif (attr->def == XML_ATTRIBUTE_REQUIRED) {\nint qualified = -1;\n(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\nxmlNsPtr ns;\nwhile (ns != NULL) {\nif (ns->prefix == NULL)\ngoto found;\nns = ns->next;\n} else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\nxmlNsPtr ns;\nwhile (ns != NULL) {\nif (xmlStrEqual(attr->name, ns->prefix))\ngoto found;\nns = ns->next;\n} else {\nxmlAttrPtr attrib;\nwhile (attrib != NULL) {\nif (xmlStrEqual(attrib->name, attr->name)) {\nif (attr->prefix != NULL) {\nxmlNsPtr nameSpace = attrib->ns;\nnameSpace = elem->ns;\nif (nameSpace == NULL) {\nif (qualified < 0)\nqualified = 0;\n} else if (!xmlStrEqual(nameSpace->prefix,\nif (qualified < 1)\nqualified = 1;\n} else\ngoto found;\n} else {\ngoto found;\n}\nattrib = attrib->next;\nif (qualified == -1) {\nif (attr->prefix == NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\nxmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n} else if (qualified == 0) {\nxmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n} else if (qualified == 1) {\nxmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n} else if (attr->def == XML_ATTRIBUTE_FIXED) {\nif ((attr->prefix == NULL) &&\n(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\nxmlNsPtr ns;\nwhile (ns != NULL) {\nif (ns->prefix == NULL) {\nif (!xmlStrEqual(attr->defaultValue, ns->href)) {\nxmlErrValidNode(ctxt, elem,\ngoto found;\nns = ns->next;\n} else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\nxmlNsPtr ns;\nwhile (ns != NULL) {\nif (xmlStrEqual(attr->name, ns->prefix)) {\nif (!xmlStrEqual(attr->defaultValue, ns->href)) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\ngoto found;\nns = ns->next;\n}\n}\nattr = attr->nexth;\nreturn(ret);", 
            "lines": [
                5942, 
                5952, 
                5954, 
                5955, 
                5957, 
                5961, 
                5962, 
                5967, 
                5968, 
                5973, 
                5974, 
                5979, 
                5982, 
                5987, 
                5989, 
                5993, 
                5999, 
                6003, 
                6007, 
                6009, 
                6017, 
                6019, 
                6025, 
                6027, 
                6029, 
                6034, 
                6035, 
                6040, 
                6043, 
                6047, 
                6048, 
                6049, 
                6051, 
                6055, 
                6057, 
                6059, 
                6060, 
                6061, 
                6062, 
                6063, 
                6069, 
                6070, 
                6071, 
                6072, 
                6073, 
                6074, 
                6075, 
                6076, 
                6077, 
                6078, 
                6079, 
                6080, 
                6081, 
                6082, 
                6083, 
                6088, 
                6090, 
                6091, 
                6092, 
                6093, 
                6094, 
                6095, 
                6096, 
                6097, 
                6098, 
                6099, 
                6100, 
                6101, 
                6102, 
                6103, 
                6104, 
                6105, 
                6106, 
                6111, 
                6113, 
                6114, 
                6119, 
                6121, 
                6123, 
                6125, 
                6131, 
                6132, 
                6133, 
                6134, 
                6136, 
                6137, 
                6138, 
                6139, 
                6146, 
                6147, 
                6149, 
                6150, 
                6154, 
                6155, 
                6157, 
                6160, 
                6161, 
                6162, 
                6163, 
                6166, 
                6167, 
                6170, 
                6171, 
                6172, 
                6173, 
                6175, 
                6176, 
                6179, 
                6180, 
                6181, 
                6182, 
                6184, 
                6185, 
                6188, 
                6189, 
                6190, 
                6191, 
                6194, 
                6200, 
                6201, 
                6202, 
                6203, 
                6205, 
                6206, 
                6207, 
                6208, 
                6209, 
                6216, 
                6218, 
                6219, 
                6222, 
                6223, 
                6224, 
                6229, 
                6234, 
                6235, 
                6238, 
                6239, 
                6243, 
                6249, 
                6250, 
                6251, 
                6254, 
                6255, 
                6256, 
                6257, 
                6263, 
                6265, 
                6267, 
                6268, 
                6271, 
                6272, 
                6273, 
                6274, 
                6279, 
                6281, 
                6283, 
                6284, 
                6286, 
                6288
            ]
        }, 
        "xmlCopyNotation": {
            "code": "xmlCopyNotation(xmlNotationPtr nota) {\nxmlVErrMemory(NULL, \"malloc failed\");\nif (nota->name != NULL)\ncur->name = xmlStrdup(nota->name);\ncur->name = NULL;\nif (nota->PublicID != NULL)\ncur->PublicID = xmlStrdup(nota->PublicID);\ncur->PublicID = NULL;\nif (nota->SystemID != NULL)\ncur->SystemID = xmlStrdup(nota->SystemID);\ncur->SystemID = NULL;\nreturn(cur);", 
            "lines": [
                2433, 
                2438, 
                2441, 
                2442, 
                2444, 
                2445, 
                2446, 
                2448, 
                2449, 
                2450, 
                2452, 
                2453
            ]
        }, 
        "xmlWalkRemoveRef": {
            "code": "xmlWalkRemoveRef(const void *data, const void *user)\nxmlListRemoveFirst(ref_list, (void *)data);\nreturn 1;", 
            "lines": [
                2861, 
                2868, 
                2871
            ]
        }, 
        "xmlDumpNotationDecl": {
            "code": "xmlDumpNotationDecl(xmlBufferPtr buf, xmlNotationPtr nota) {\nif ((buf == NULL) || (nota == NULL))\nreturn;\nxmlBufferWriteChar(buf, \"<!NOTATION \");\nxmlBufferWriteChar(buf, \" PUBLIC \");\nxmlBufferWriteChar(buf, \" \");\n} else {\nxmlBufferWriteChar(buf, \" SYSTEM \");\nxmlBufferWriteChar(buf, \" >\\n\");", 
            "lines": [
                2480, 
                2481, 
                2482, 
                2483, 
                2486, 
                2489, 
                2492, 
                2493, 
                2496
            ]
        }, 
        "xmlGetRefs": {
            "code": "xmlGetRefs(xmlDocPtr doc, const xmlChar *ID) {\nreturn(NULL);\nif (ID == NULL) {\nreturn(NULL);\ntable = (xmlRefTablePtr) doc->refs;\nreturn(NULL);\nreturn (xmlHashLookup(table, ID));", 
            "lines": [
                3112, 
                3116, 
                3119, 
                3120, 
                3123, 
                3125, 
                3127
            ]
        }, 
        "xmlValidateDocument": {
            "code": "xmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\nreturn(0);\nif ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\nxmlErrValid(ctxt, XML_DTD_NO_DTD,\nif ((doc->intSubset != NULL) && ((doc->intSubset->SystemID != NULL) ||\n(doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\nxmlChar *sysID;\nsysID = xmlBuildURI(doc->intSubset->SystemID,\nxmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n} else\nsysID = NULL;\ndoc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,\nxmlFree(sysID);\nif (doc->extSubset == NULL) {\nif (doc->intSubset->SystemID != NULL) {\nxmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\nxmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\nreturn(0);\n}\nif (doc->ids != NULL) {\nxmlFreeIDTable(doc->ids);\nif (doc->refs != NULL) {\nxmlFreeRefTable(doc->refs);\nret = xmlValidateDtdFinal(ctxt, doc);\nif (!xmlValidateRoot(ctxt, doc)) return(0);\nroot = xmlDocGetRootElement(doc);", 
            "lines": [
                6802, 
                6807, 
                6808, 
                6809, 
                6813, 
                6814, 
                6815, 
                6817, 
                6820, 
                6825, 
                6826, 
                6827, 
                6830, 
                6831, 
                6832, 
                6833, 
                6837, 
                6841, 
                6843, 
                6845, 
                6846, 
                6849, 
                6850, 
                6853, 
                6854, 
                6856
            ]
        }, 
        "xmlScanIDAttributeDecl": {
            "code": "xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {\nif (elem == NULL) return(0);\ncur = elem->attributes;\nwhile (cur != NULL) {\nif (cur->atype == XML_ATTRIBUTE_ID) {\nret ++;\nif ((ret > 1) && (err))\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n}\ncur = cur->nexth;\nreturn(ret);", 
            "lines": [
                1846, 
                1850, 
                1851, 
                1852, 
                1853, 
                1854, 
                1855, 
                1856, 
                1859, 
                1860, 
                1862
            ]
        }, 
        "xmlValidateElementDecl": {
            "code": "xmlValidateElementDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nCHECK_DTD;\nif (elem == NULL) return(1);\nif (elem->etype == XML_ELEMENT_TYPE_MIXED) {\nxmlElementContentPtr cur, next;\nwhile (cur != NULL) {\nif (cur->type != XML_ELEMENT_CONTENT_OR) break;\nif (cur->c1 == NULL) break;\nif (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\nname = cur->c1->name;\nwhile (next != NULL) {\nif (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\nif ((xmlStrEqual(next->name, name)) &&\n(xmlStrEqual(next->prefix, cur->c1->prefix))) {\nif (cur->c1->prefix == NULL) {\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\nret = 0;\nbreak;\nif (next->c1 == NULL) break;\nif (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\nif ((xmlStrEqual(next->c1->name, name)) &&\n(xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\nif (cur->c1->prefix == NULL) {\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\nret = 0;\nnext = next->c2;\n}\ncur = cur->c2;\n}\ntst = xmlGetDtdElementDesc(doc->intSubset, elem->name);\nif ((tst != NULL ) && (tst != elem) &&\n((tst->prefix == elem->prefix) ||\n(xmlStrEqual(tst->prefix, elem->prefix))) &&\n(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\ntst = xmlGetDtdElementDesc(doc->extSubset, elem->name);\nif ((tst != NULL ) && (tst != elem) &&\n((tst->prefix == elem->prefix) ||\n(xmlStrEqual(tst->prefix, elem->prefix))) &&\n(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\nxmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\nreturn(ret);", 
            "lines": [
                4228, 
                4233, 
                4235, 
                4245, 
                4246, 
                4250, 
                4251, 
                4252, 
                4253, 
                4254, 
                4256, 
                4257, 
                4258, 
                4259, 
                4260, 
                4261, 
                4265, 
                4269, 
                4271, 
                4273, 
                4274, 
                4275, 
                4276, 
                4277, 
                4278, 
                4282, 
                4286, 
                4288, 
                4290, 
                4291, 
                4293, 
                4296, 
                4297, 
                4298, 
                4299, 
                4300, 
                4301, 
                4306, 
                4307, 
                4308, 
                4309, 
                4310, 
                4311, 
                4321
            ]
        }, 
        "nodeVPop": {
            "code": "nodeVPop(xmlValidCtxtPtr ctxt)\nreturn (NULL);\nctxt->nodeNr--;\nctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];\nctxt->node = NULL;\nret = ctxt->nodeTab[ctxt->nodeNr];", 
            "lines": [
                466, 
                471, 
                472, 
                474, 
                476, 
                477
            ]
        }, 
        "xmlValidateNmtokenValueInternal": {
            "code": "xmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {\nif (value == NULL) return(0);\ncur = value;\nreturn(0);\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (val != 0) return(0);\nreturn(1);", 
            "lines": [
                3609, 
                3613, 
                3614, 
                3619, 
                3621, 
                3623, 
                3624, 
                3628, 
                3630
            ]
        }, 
        "xmlGetID": {
            "code": "xmlGetID(xmlDocPtr doc, const xmlChar *ID) {\nreturn(NULL);\nif (ID == NULL) {\nreturn(NULL);\ntable = (xmlIDTablePtr) doc->ids;\nreturn(NULL);\nid = xmlHashLookup(table, ID);\nreturn(NULL);\nif (id->attr == NULL) {\nreturn((xmlAttrPtr) doc);\nreturn(id->attr);", 
            "lines": [
                2774, 
                2779, 
                2782, 
                2783, 
                2786, 
                2788, 
                2790, 
                2792, 
                2793, 
                2798, 
                2800
            ]
        }, 
        "xmlNewDocElementContent": {
            "code": "xmlNewDocElementContent(xmlDocPtr doc, const xmlChar *name,\ndict = doc->dict;\nswitch(type) {\nif (name == NULL) {\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nbreak;\nif (name != NULL) {\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nbreak;\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(ret, 0, sizeof(xmlElementContent));\nint l;\nif (dict == NULL)\nret->name = xmlStrdup(name);\nret->name = xmlDictLookup(dict, name, -1);\n} else {\nif (dict == NULL) {\nret->prefix = xmlStrndup(name, l);\nret->prefix = xmlDictLookup(dict, name, l);\n}\nreturn(ret);", 
            "lines": [
                921, 
                927, 
                929, 
                931, 
                932, 
                936, 
                940, 
                941, 
                945, 
                947, 
                952, 
                954, 
                957, 
                961, 
                966, 
                967, 
                969, 
                970, 
                971, 
                972, 
                975, 
                979, 
                980
            ]
        }, 
        "xmlValidateAttributeDecl": {
            "code": "xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nCHECK_DTD;\nif(attr == NULL) return(1);\nif (attr->defaultValue != NULL) {\nval = xmlValidateAttributeValueInternal(doc, attr->atype,\nxmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\nret &= val;\nif ((attr->atype == XML_ATTRIBUTE_ID)&&\n(attr->def != XML_ATTRIBUTE_IMPLIED) &&\n(attr->def != XML_ATTRIBUTE_REQUIRED)) {\nxmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\nif (attr->atype == XML_ATTRIBUTE_ID) {\nint nbId;\nnbId = xmlScanIDAttributeDecl(NULL, elem, 0);\nxmlAttributeTablePtr table;\ntable = (xmlAttributeTablePtr) doc->intSubset->attributes;\nif (nbId > 1) {\nxmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n} else if (doc->extSubset != NULL) {\nint extId = 0;\nextId = xmlScanIDAttributeDecl(NULL, elem, 0);\nif (extId > 1) {\nxmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n} else if (extId + nbId > 1) {\nxmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n}\n}\nif ((attr->defaultValue != NULL) && (attr->tree != NULL)) {\nxmlEnumerationPtr tree = attr->tree;\nwhile (tree != NULL) {\nif (xmlStrEqual(tree->name, attr->defaultValue)) break;\ntree = tree->next;\nif (tree == NULL) {\nxmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n}\nreturn(ret);", 
            "lines": [
                4117, 
                4121, 
                4122, 
                4126, 
                4127, 
                4130, 
                4134, 
                4138, 
                4139, 
                4140, 
                4141, 
                4148, 
                4149, 
                4155, 
                4157, 
                4165, 
                4170, 
                4172, 
                4175, 
                4176, 
                4179, 
                4181, 
                4182, 
                4185, 
                4186, 
                4190, 
                4191, 
                4194, 
                4195, 
                4196, 
                4197, 
                4198, 
                4200, 
                4201, 
                4206, 
                4208
            ]
        }, 
        "xmlRemoveRef": {
            "code": "xmlRemoveRef(xmlDocPtr doc, xmlAttrPtr attr) {\nif (doc == NULL) return(-1);\nif (attr == NULL) return(-1);\ntable = (xmlRefTablePtr) doc->refs;\nreturn(-1);\nID = xmlNodeListGetString(doc, attr->children, 1);\nreturn(-1);\nref_list = xmlHashLookup(table, ID);\nxmlFree(ID);\ntarget.l = ref_list;\nxmlHashUpdateEntry(table, ID, NULL, (xmlHashDeallocator)\nxmlFree(ID);", 
            "lines": [
                3055, 
                3061, 
                3062, 
                3064, 
                3066, 
                3068, 
                3070, 
                3072, 
                3074, 
                3088, 
                3096, 
                3098
            ]
        }, 
        "xmlIsMixedElement": {
            "code": "xmlIsMixedElement(xmlDocPtr doc, const xmlChar *name) {\nif ((doc == NULL) || (doc->intSubset == NULL)) return(-1);\nelemDecl = xmlGetDtdElementDesc(doc->intSubset, name);\nif ((elemDecl == NULL) && (doc->extSubset != NULL))\nelemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\nif (elemDecl == NULL) return(-1);\nswitch (elemDecl->etype) {\nreturn(-1);\nreturn(0);\nreturn(1);\nreturn(1);", 
            "lines": [
                3384, 
                3387, 
                3389, 
                3390, 
                3391, 
                3392, 
                3393, 
                3395, 
                3397, 
                3405, 
                3407
            ]
        }, 
        "xmlCopyDocElementContent": {
            "code": "xmlCopyDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\nif (cur == NULL) return(NULL);\nif (doc != NULL)\ndict = doc->dict;\nret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(ret, 0, sizeof(xmlElementContent));\nif (dict)\nret->name = xmlDictLookup(dict, cur->name, -1);\nret->name = xmlStrdup(cur->name);\n}\nif (cur->prefix != NULL) {\nif (dict)\nret->prefix = xmlDictLookup(dict, cur->prefix, -1);\nret->prefix = xmlStrdup(cur->prefix);\n}\nif (cur->c1 != NULL)\nret->c1 = xmlCopyDocElementContent(doc, cur->c1);\nif (ret->c1 != NULL)\nret->c1->parent = ret;\nif (cur->c2 != NULL) {\nprev = ret;\nwhile (cur != NULL) {\ntmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(tmp, 0, sizeof(xmlElementContent));\nif (dict)\ntmp->name = xmlDictLookup(dict, cur->name, -1);\ntmp->name = xmlStrdup(cur->name);\n}\nif (cur->prefix != NULL) {\nif (dict)\ntmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\ntmp->prefix = xmlStrdup(cur->prefix);\n}\nif (cur->c1 != NULL)\ntmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\nif (tmp->c1 != NULL)\ntmp->c1->parent = ret;\nprev = tmp;\n}\nreturn(ret);", 
            "lines": [
                1008, 
                1012, 
                1014, 
                1015, 
                1017, 
                1019, 
                1022, 
                1026, 
                1027, 
                1029, 
                1030, 
                1032, 
                1033, 
                1034, 
                1036, 
                1037, 
                1038, 
                1039, 
                1040, 
                1041, 
                1042, 
                1043, 
                1045, 
                1046, 
                1048, 
                1051, 
                1056, 
                1057, 
                1059, 
                1060, 
                1062, 
                1063, 
                1064, 
                1066, 
                1067, 
                1068, 
                1069, 
                1070, 
                1071, 
                1072, 
                1075, 
                1076
            ]
        }, 
        "xmlErrValidWarning": {
            "code": "xmlErrValidWarning(xmlValidCtxtPtr ctxt,\nchannel = ctxt->warning;\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\nlong delta = (char *) ctxt - (char *) ctxt->userData;\nif ((delta > 0) && (delta < 250))\npctxt = ctxt->userData;\n}\n}", 
            "lines": [
                225, 
                236, 
                241, 
                242, 
                243, 
                244, 
                245, 
                246
            ]
        }, 
        "xmlRemoveID": {
            "code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\nif (doc == NULL) return(-1);\nif (attr == NULL) return(-1);\ntable = (xmlIDTablePtr) doc->ids;\nreturn(-1);\nID = xmlNodeListGetString(doc, attr->children, 1);\nreturn(-1);\nid = xmlHashLookup(table, ID);\nif (id == NULL || id->attr != attr) {\nxmlFree(ID);\nxmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);", 
            "lines": [
                2736, 
                2741, 
                2742, 
                2744, 
                2746, 
                2748, 
                2750, 
                2752, 
                2753, 
                2754, 
                2758
            ]
        }, 
        "xmlValidateDocumentFinal": {
            "code": "xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\nreturn(0);\nif (doc == NULL) {\nxmlErrValid(ctxt, XML_DTD_NO_DOC,\nsave = ctxt->finishDtd;", 
            "lines": [
                6563, 
                6568, 
                6569, 
                6570, 
                6576
            ]
        }, 
        "xmlValidCtxtNormalizeAttributeValue": {
            "code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nif (doc == NULL) return(NULL);\nif (elem == NULL) return(NULL);\nif (name == NULL) return(NULL);\nif (value == NULL) return(NULL);\nif ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\nxmlChar fn[50];\nreturn(NULL);\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\nif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\nextsubset = 1;\n}\nif ((fullname != fn) && (fullname != elem->name))\nxmlFree(fullname);\n}\nif ((attrDecl == NULL) && (doc->intSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\nif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\nextsubset = 1;\n}\nif (attrDecl == NULL)\nreturn(NULL);\nif (attrDecl->atype == XML_ATTRIBUTE_CDATA)\nreturn(NULL);\nret = xmlStrdup(value);\nreturn(NULL);\nsrc = value;\nwhile (*src == 0x20) src++;\nwhile (*src != 0) {\nif (*src == 0x20) {\nwhile (*src == 0x20) src++;\nif (*src != 0)\n*dst++ = 0x20;\n} else {\n*dst++ = *src++;\n*dst = 0;\nif ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\nxmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\nreturn(ret);", 
            "lines": [
                3957, 
                3964, 
                3965, 
                3966, 
                3967, 
                3969, 
                3970, 
                3975, 
                3976, 
                3977, 
                3978, 
                3980, 
                3981, 
                3982, 
                3983, 
                3984, 
                3985, 
                3986, 
                3987, 
                3988, 
                3990, 
                3991, 
                3993, 
                3994, 
                3995, 
                3996, 
                3998, 
                4000, 
                4001, 
                4003, 
                4004, 
                4005, 
                4006, 
                4007, 
                4008, 
                4009, 
                4010, 
                4013, 
                4014, 
                4015, 
                4020
            ]
        }, 
        "xmlFreeElement": {
            "code": "xmlFreeElement(xmlElementPtr elem) {\nif (elem == NULL) return;\nxmlUnlinkNode((xmlNodePtr) elem);\nxmlFree((xmlChar *) elem->name);\nif (elem->prefix != NULL)\nxmlFree((xmlChar *) elem->prefix);\nif (elem->contModel != NULL)\nxmlRegFreeRegexp(elem->contModel);\nxmlFree(elem);", 
            "lines": [
                1352, 
                1353, 
                1354, 
                1357, 
                1358, 
                1359, 
                1361, 
                1362, 
                1364
            ]
        }, 
        "xmlFreeDocElementContent": {
            "code": "xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\ndict = doc->dict;\nwhile (cur != NULL) {\nnext = cur->c2;\nbreak;\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nif (cur->c1 != NULL) xmlFreeDocElementContent(doc, cur->c1);\nif (dict) {\nif ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\nxmlFree((xmlChar *) cur->name);\nif ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\nxmlFree((xmlChar *) cur->prefix);\n} else {\nif (cur->name != NULL) xmlFree((xmlChar *) cur->name);\nif (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\nxmlFree(cur);", 
            "lines": [
                1101, 
                1106, 
                1108, 
                1109, 
                1115, 
                1117, 
                1122, 
                1123, 
                1124, 
                1125, 
                1126, 
                1127, 
                1128, 
                1129, 
                1130, 
                1132
            ]
        }, 
        "xmlValidateCheckRefCallback": {
            "code": "xmlValidateCheckRefCallback(xmlListPtr ref_list, xmlValidCtxtPtr ctxt,\nreturn;\nmemo.ctxt = ctxt;", 
            "lines": [
                6534, 
                6539, 
                6540
            ]
        }, 
        "xmlNewValidCtxt": {
            "code": "xmlValidCtxtPtr ret;\nxmlVErrMemory(NULL, \"malloc failed\");\n(void) memset(ret, 0, sizeof (xmlValidCtxt));", 
            "lines": [
                881, 
                884, 
                888
            ]
        }, 
        "xmlSnprintfElements": {
            "code": "xmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {\nif (node == NULL) return;\nif (glob) strcat(buf, \"(\");\ncur = node;\nwhile (cur != NULL) {\nlen = strlen(buf);\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nswitch (cur->type) {\nif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\nif (size - len < xmlStrlen(cur->ns->prefix) + 10) {\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nstrcat(buf, (char *) cur->ns->prefix);\nif (size - len < xmlStrlen(cur->name) + 10) {\nif ((size - len > 4) && (buf[len - 1] != '.'))\nstrcat(buf, \" ...\");\nreturn;\nstrcat(buf, (char *) cur->name);\nstrcat(buf, \" \");\nbreak;\nif (xmlIsBlankNode(cur))\nbreak;\nstrcat(buf, \"CDATA\");\nstrcat(buf, \" \");\nbreak;\nstrcat(buf, \"???\");\nstrcat(buf, \" \");\nbreak;\nbreak;\ncur = cur->next;\nif (glob) strcat(buf, \")\");", 
            "lines": [
                5143, 
                5147, 
                5148, 
                5149, 
                5150, 
                5151, 
                5153, 
                5154, 
                5155, 
                5157, 
                5159, 
                5160, 
                5161, 
                5162, 
                5163, 
                5165, 
                5168, 
                5169, 
                5170, 
                5171, 
                5173, 
                5175, 
                5176, 
                5178, 
                5179, 
                5182, 
                5184, 
                5185, 
                5196, 
                5198, 
                5199, 
                5209, 
                5211, 
                5213
            ]
        }, 
        "xmlValidateOneNamespace": {
            "code": "xmlValidateOneNamespace(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nCHECK_DTD;\nif ((elem == NULL) || (elem->name == NULL)) return(0);\nif ((ns == NULL) || (ns->href == NULL)) return(0);\nif (prefix != NULL) {\nxmlChar fn[50];\nxmlVErrMemory(ctxt, \"Validating namespace\");\nif (ns->prefix != NULL) {\nattrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n} else {\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,\nif ((fullname != fn) && (fullname != elem->name))\nxmlFree(fullname);\n}\nif (attrDecl == NULL) {\nif (ns->prefix != NULL) {\nattrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n} else {\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n}\nif (attrDecl == NULL) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\nreturn(0);\nval = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\nxmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\nret = 0;\nif (attrDecl->def == XML_ATTRIBUTE_FIXED) {\nif (!xmlStrEqual(value, attrDecl->defaultValue)) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\nret = 0;\n}\nif (attrDecl->atype == XML_ATTRIBUTE_ID) {\nif (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\nret = 0;\n}\nif ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\nif (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\nret = 0;\n}\nif (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\nxmlEnumerationPtr tree = attrDecl->tree;\nnota = xmlGetDtdNotationDesc(doc->extSubset, value);\nif (nota == NULL) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\nxmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\nret = 0;\nwhile (tree != NULL) {\nif (xmlStrEqual(tree->name, value)) break;\ntree = tree->next;\nif (tree == NULL) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\nxmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\nret = 0;\n}\nif (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\nxmlEnumerationPtr tree = attrDecl->tree;\nwhile (tree != NULL) {\nif (xmlStrEqual(tree->name, value)) break;\ntree = tree->next;\nif (tree == NULL) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\nxmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\nret = 0;\n}\nif ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n(!xmlStrEqual(attrDecl->defaultValue, value))) {\nif (ns->prefix != NULL) {\nxmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\nxmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\nret = 0;\nif (ns->prefix != NULL) {\nret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\nret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\nreturn(ret);", 
            "lines": [
                4527, 
                4534, 
                4535, 
                4536, 
                4538, 
                4539, 
                4544, 
                4547, 
                4548, 
                4550, 
                4551, 
                4553, 
                4554, 
                4556, 
                4557, 
                4560, 
                4561, 
                4562, 
                4563, 
                4564, 
                4565, 
                4567, 
                4568, 
                4570, 
                4571, 
                4573, 
                4574, 
                4577, 
                4581, 
                4582, 
                4583, 
                4587, 
                4591, 
                4594, 
                4596, 
                4597, 
                4601, 
                4605, 
                4609, 
                4610, 
                4611, 
                4612, 
                4616, 
                4620, 
                4622, 
                4625, 
                4626, 
                4627, 
                4628, 
                4630, 
                4631, 
                4632, 
                4633, 
                4634, 
                4637, 
                4638, 
                4644, 
                4646, 
                4647, 
                4648, 
                4652, 
                4656, 
                4660, 
                4661, 
                4662, 
                4664, 
                4665, 
                4666, 
                4670, 
                4674, 
                4676, 
                4679, 
                4680, 
                4681, 
                4682, 
                4683, 
                4685, 
                4686, 
                4687, 
                4691, 
                4695, 
                4697, 
                4700, 
                4701, 
                4702, 
                4703, 
                4707, 
                4711, 
                4715, 
                4716, 
                4719, 
                4723
            ]
        }, 
        "xmlValidateDtdFinal": {
            "code": "xmlValidateDtdFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\nif ((doc == NULL) || (ctxt == NULL)) return(0);\nif ((doc->intSubset == NULL) && (doc->extSubset == NULL))\nreturn(0);\nctxt->doc = doc;\nif ((dtd != NULL) && (dtd->attributes != NULL)) {\ntable = (xmlAttributeTablePtr) dtd->attributes;\nif ((dtd != NULL) && (dtd->entities != NULL)) {\nentities = (xmlEntitiesTablePtr) dtd->entities;\ndtd = doc->extSubset;\nif ((dtd != NULL) && (dtd->attributes != NULL)) {\ntable = (xmlAttributeTablePtr) dtd->attributes;\nif ((dtd != NULL) && (dtd->entities != NULL)) {\nentities = (xmlEntitiesTablePtr) dtd->entities;\nreturn(ctxt->valid);", 
            "lines": [
                6754, 
                6759, 
                6760, 
                6761, 
                6762, 
                6765, 
                6766, 
                6769, 
                6770, 
                6774, 
                6775, 
                6776, 
                6779, 
                6780, 
                6784
            ]
        }, 
        "xmlCreateEnumeration": {
            "code": "xmlCreateEnumeration(const xmlChar *name) {\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(ret, 0, sizeof(xmlEnumeration));\nret->name = xmlStrdup(name);\nreturn(ret);", 
            "lines": [
                1754, 
                1759, 
                1762, 
                1765, 
                1766
            ]
        }, 
        "xmlValidateCheckMixed": {
            "code": "xmlValidateCheckMixed(xmlValidCtxtPtr ctxt,\nwhile (cont != NULL) {\nif (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\nif ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\nreturn(1);\n} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n(cont->c1 != NULL) &&\n(cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\nif ((cont->c1->prefix == NULL) &&\n(xmlStrEqual(cont->c1->name, qname)))\nreturn(1);\n} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n(cont->c1 == NULL) ||\n(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\nxmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\ncont = cont->c2;\n} else {\nwhile (cont != NULL) {\nif (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\nif ((cont->prefix != NULL) &&\n(xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n(xmlStrEqual(cont->name, name)))\nreturn(1);\n} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n(cont->c1 != NULL) &&\n(cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\nif ((cont->c1->prefix != NULL) &&\n(xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n(xmlStrEqual(cont->c1->name, name)))\nreturn(1);\n} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n(cont->c1 == NULL) ||\n(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\nxmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\ncont = cont->c2;\nreturn(0);", 
            "lines": [
                5583, 
                5590, 
                5591, 
                5592, 
                5593, 
                5594, 
                5595, 
                5596, 
                5597, 
                5598, 
                5599, 
                5600, 
                5601, 
                5602, 
                5603, 
                5608, 
                5610, 
                5611, 
                5612, 
                5613, 
                5614, 
                5615, 
                5616, 
                5617, 
                5618, 
                5619, 
                5620, 
                5621, 
                5622, 
                5623, 
                5624, 
                5625, 
                5626, 
                5627, 
                5632, 
                5635
            ]
        }, 
        "xmlAddNotationDecl": {
            "code": "xmlAddNotationDecl(xmlValidCtxtPtr ctxt, xmlDtdPtr dtd,\nreturn(NULL);\nif (name == NULL) {\nreturn(NULL);\nif ((PublicID == NULL) && (SystemID == NULL)) {\nreturn(NULL);\ntable = (xmlNotationTablePtr) dtd->notations;\nxmlDictPtr dict = NULL;\ndict = dtd->doc->dict;\ndtd->notations = table = xmlHashCreateDict(0, dict);\nif (table == NULL) {\nxmlVErrMemory(ctxt,\nret = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));\nxmlVErrMemory(ctxt, \"malloc failed\");\nmemset(ret, 0, sizeof(xmlNotation));\nret->SystemID = xmlStrdup(SystemID);\nif (PublicID != NULL)\nret->PublicID = xmlStrdup(PublicID);\nif (xmlHashAddEntry(table, name, ret)) {\n(const char *) name);\nreturn(ret);", 
            "lines": [
                2347, 
                2354, 
                2356, 
                2357, 
                2359, 
                2360, 
                2366, 
                2368, 
                2370, 
                2372, 
                2374, 
                2375, 
                2380, 
                2382, 
                2385, 
                2392, 
                2393, 
                2394, 
                2400, 
                2404, 
                2409
            ]
        }, 
        "xmlAddAttributeDecl": {
            "code": "xmlAddAttributeDecl(xmlValidCtxtPtr ctxt,\nxmlFreeEnumeration(tree);\nif (name == NULL) {\nxmlFreeEnumeration(tree);\nif (elem == NULL) {\nxmlFreeEnumeration(tree);\nif (dtd->doc != NULL)\ndict = dtd->doc->dict;\nswitch (type) {\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nif ((defaultValue != NULL) &&\n(!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {\nxmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\nctxt->valid = 0;\n}\nif ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&\n(dtd->doc->intSubset != NULL) &&\n(dtd->doc->intSubset->attributes != NULL)) {\nret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);\nxmlFreeEnumeration(tree);\n}\ntable = (xmlAttributeTablePtr) dtd->attributes;\ntable = xmlHashCreateDict(0, dict);\nif (table == NULL) {\nxmlVErrMemory(ctxt,\nret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\nxmlVErrMemory(ctxt, \"malloc failed\");\nmemset(ret, 0, sizeof(xmlAttribute));\nret->name = xmlDictLookup(dict, name, -1);\nret->name = xmlStrdup(name);\nret->def = def;\nif (dict)\nret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\nret->defaultValue = xmlStrdup(defaultValue);\n}\nif (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {\nxmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,\nelemDef = xmlGetDtdElementDesc2(dtd, elem, 1);\nif ((type == XML_ATTRIBUTE_ID) &&\n(xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {\nxmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,\nctxt->valid = 0;\n}\nif ((xmlStrEqual(ret->name, BAD_CAST \"xmlns\")) ||\n((ret->prefix != NULL &&\n(xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\"))))) {\nret->nexth = elemDef->attributes;\nxmlAttributePtr tmp = elemDef->attributes;\nwhile ((tmp != NULL) &&\n((xmlStrEqual(tmp->name, BAD_CAST \"xmlns\")) ||\n((ret->prefix != NULL &&\n(xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\")))))) {\nif (tmp->nexth == NULL)\nbreak;\ntmp = tmp->nexth;\nif (tmp != NULL) {\nret->nexth = tmp->nexth;\nret->nexth = elemDef->attributes;\n}\nret->parent = dtd;\ndtd->children = dtd->last = (xmlNodePtr) ret;\ndtd->last->next = (xmlNodePtr) ret;\nreturn(ret);", 
            "lines": [
                1926, 
                1937, 
                1940, 
                1941, 
                1944, 
                1945, 
                1948, 
                1949, 
                1955, 
                1957, 
                1959, 
                1961, 
                1963, 
                1965, 
                1967, 
                1969, 
                1971, 
                1973, 
                1975, 
                1977, 
                1983, 
                1984, 
                1985, 
                1990, 
                1991, 
                1998, 
                1999, 
                2000, 
                2001, 
                2003, 
                2006, 
                2011, 
                2013, 
                2016, 
                2017, 
                2024, 
                2026, 
                2030, 
                2044, 
                2048, 
                2052, 
                2055, 
                2056, 
                2058, 
                2059, 
                2065, 
                2070, 
                2082, 
                2086, 
                2087, 
                2088, 
                2092, 
                2093, 
                2100, 
                2101, 
                2102, 
                2103, 
                2106, 
                2108, 
                2109, 
                2110, 
                2111, 
                2112, 
                2113, 
                2114, 
                2116, 
                2117, 
                2120, 
                2124, 
                2129, 
                2131, 
                2133, 
                2137
            ]
        }, 
        "xmlErrValid": {
            "code": "xmlErrValid(xmlValidCtxtPtr ctxt, xmlParserErrors error,\nchannel = ctxt->error;\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\nlong delta = (char *) ctxt - (char *) ctxt->userData;\nif ((delta > 0) && (delta < 250))\npctxt = ctxt->userData;\n}\n}\nif (extra)\n__xmlRaiseError(NULL, channel, data,\n__xmlRaiseError(NULL, channel, data,", 
            "lines": [
                97, 
                105, 
                110, 
                111, 
                112, 
                113, 
                114, 
                115, 
                116, 
                117, 
                122
            ]
        }, 
        "xmlErrValidNode": {
            "code": "xmlErrValidNode(xmlValidCtxtPtr ctxt,\nchannel = ctxt->error;\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\nlong delta = (char *) ctxt - (char *) ctxt->userData;\nif ((delta > 0) && (delta < 250))\npctxt = ctxt->userData;\n}\n}", 
            "lines": [
                141, 
                152, 
                157, 
                158, 
                159, 
                160, 
                161, 
                162
            ]
        }, 
        "xmlCopyElement": {
            "code": "xmlCopyElement(xmlElementPtr elem) {\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(cur, 0, sizeof(xmlElement));\ncur->name = xmlStrdup(elem->name);\ncur->name = NULL;\nif (elem->prefix != NULL)\ncur->prefix = xmlStrdup(elem->prefix);\ncur->prefix = NULL;\ncur->content = xmlCopyElementContent(elem->content);", 
            "lines": [
                1615, 
                1620, 
                1623, 
                1627, 
                1629, 
                1630, 
                1631, 
                1633, 
                1634
            ]
        }, 
        "xmlValidateAttributeIdCallback": {
            "code": "xmlValidateAttributeIdCallback(xmlAttributePtr attr, int *count,\nif (attr->atype == XML_ATTRIBUTE_ID) (*count)++;", 
            "lines": [
                4093, 
                4095
            ]
        }, 
        "xmlDumpElementDecl": {
            "code": "xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {\nif ((buf == NULL) || (elem == NULL))\nreturn;\nswitch (elem->etype) {\nxmlBufferWriteChar(buf, \"<!ELEMENT \");\nxmlBufferWriteCHAR(buf, elem->prefix);\nxmlBufferWriteCHAR(buf, elem->name);\nxmlBufferWriteChar(buf, \"<!ELEMENT \");\nxmlBufferWriteCHAR(buf, elem->prefix);\nxmlBufferWriteCHAR(buf, elem->name);\nxmlBufferWriteChar(buf, \"<!ELEMENT \");\nxmlBufferWriteCHAR(buf, elem->prefix);\nxmlBufferWriteCHAR(buf, elem->name);\nxmlBufferWriteChar(buf, \"<!ELEMENT \");\nxmlBufferWriteCHAR(buf, elem->prefix);\nxmlBufferWriteCHAR(buf, elem->name);\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,", 
            "lines": [
                1665, 
                1666, 
                1667, 
                1668, 
                1670, 
                1672, 
                1675, 
                1679, 
                1681, 
                1684, 
                1688, 
                1690, 
                1693, 
                1699, 
                1701, 
                1704, 
                1710
            ]
        }, 
        "xmlErrValidNodeNr": {
            "code": "xmlErrValidNodeNr(xmlValidCtxtPtr ctxt,\nchannel = ctxt->error;\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\nlong delta = (char *) ctxt - (char *) ctxt->userData;\nif ((delta > 0) && (delta < 250))\npctxt = ctxt->userData;\n}\n}", 
            "lines": [
                184, 
                195, 
                200, 
                201, 
                202, 
                203, 
                204, 
                205
            ]
        }, 
        "xmlValidGetElemDecl": {
            "code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nif ((ctxt == NULL) || (doc == NULL) ||\n(elem == NULL) || (elem->name == NULL))\nreturn(NULL);\nif (extsubset != NULL)\n*extsubset = 0;\nif ((elem->ns != NULL) && (elem->ns->prefix != NULL))\nprefix = elem->ns->prefix;\nif (prefix != NULL) {\nelemDecl = xmlGetDtdQElementDesc(doc->intSubset,\nif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\nelemDecl = xmlGetDtdQElementDesc(doc->extSubset,\nif ((elemDecl != NULL) && (extsubset != NULL))\n*extsubset = 1;\n}\n}\nif (elemDecl == NULL) {\nelemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\nif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\nelemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\nif ((elemDecl != NULL) && (extsubset != NULL))\n*extsubset = 1;\n}\n}\nif (elemDecl == NULL) {\nxmlErrValidNode(ctxt, elem,\nreturn(elemDecl);", 
            "lines": [
                5651, 
                5656, 
                5657, 
                5658, 
                5659, 
                5660, 
                5665, 
                5666, 
                5668, 
                5669, 
                5671, 
                5672, 
                5674, 
                5675, 
                5676, 
                5677, 
                5684, 
                5685, 
                5686, 
                5687, 
                5688, 
                5689, 
                5690, 
                5691, 
                5692, 
                5693, 
                5698
            ]
        }, 
        "xmlGetDtdQElementDesc": {
            "code": "xmlGetDtdQElementDesc(xmlDtdPtr dtd, const xmlChar *name,\nif (dtd == NULL) return(NULL);\nif (dtd->elements == NULL) return(NULL);\ntable = (xmlElementTablePtr) dtd->elements;", 
            "lines": [
                3245, 
                3249, 
                3250, 
                3251
            ]
        }, 
        "nodeVPush": {
            "code": "nodeVPush(xmlValidCtxtPtr ctxt, xmlNodePtr value)\nctxt->nodeMax = 4;\nxmlVErrMemory(ctxt, \"malloc failed\");\n}\nif (ctxt->nodeNr >= ctxt->nodeMax) {\nxmlNodePtr *tmp;\nxmlVErrMemory(ctxt, \"realloc failed\");\nctxt->nodeMax *= 2;\nctxt->nodeTab[ctxt->nodeNr] = value;", 
            "lines": [
                437, 
                440, 
                445, 
                449, 
                450, 
                451, 
                455, 
                458, 
                461
            ]
        }, 
        "xmlValidatePopElement": {
            "code": "xmlValidatePopElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc ATTRIBUTE_UNUSED,\nreturn(0);\nif ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\nxmlValidStatePtr state = ctxt->vstate;\nelemDecl = state->elemDecl;\nif (state->exec != NULL) {\nret = xmlRegExecPushString(state->exec, NULL, NULL);\nxmlErrValidNode(ctxt, state->node,\nret = 1;\n}\n}\n}\nvstateVPop(ctxt);\nreturn(ret);", 
            "lines": [
                5881, 
                5887, 
                5889, 
                5890, 
                5897, 
                5900, 
                5901, 
                5903, 
                5912, 
                5914, 
                5915, 
                5916, 
                5917, 
                5919
            ]
        }, 
        "xmlValidBuildAContentModel": {
            "code": "xmlValidBuildAContentModel(xmlElementContentPtr content,\nxmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\nswitch (content->type) {\nxmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\nxmlAutomataStatePtr oldstate = ctxt->state;\nxmlVErrMemory(ctxt, \"Building content model\");\nswitch (content->ocur) {\nctxt->state = xmlAutomataNewTransition(ctxt->am,\nctxt->state = xmlAutomataNewTransition(ctxt->am,\nctxt->state = xmlAutomataNewTransition(ctxt->am,\nctxt->state = xmlAutomataNewEpsilon(ctxt->am,\nif ((fullname != fn) && (fullname != content->name))\nxmlFree(fullname);\nbreak;\nxmlAutomataStatePtr oldstate, oldend;\nctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\ndo {\nxmlValidBuildAContentModel(content->c1, ctxt, name);\n} while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n(content->ocur == XML_ELEMENT_CONTENT_ONCE));\nxmlValidBuildAContentModel(content, ctxt, name);\nbreak;\nxmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\nxmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\nxmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\nbreak;\nxmlAutomataStatePtr oldstate, oldend;\n(ocur == XML_ELEMENT_CONTENT_MULT)) {\nctxt->state = xmlAutomataNewEpsilon(ctxt->am,\noldstate = ctxt->state;\nctxt->state = oldstate;\n} while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n(content->ocur == XML_ELEMENT_CONTENT_ONCE));\nctxt->state = oldstate;\nbreak;\nxmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\nxmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\nxmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\nbreak;\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nreturn(1);", 
            "lines": [
                659, 
                663, 
                668, 
                670, 
                676, 
                682, 
                686, 
                688, 
                692, 
                697, 
                703, 
                709, 
                710, 
                711, 
                714, 
                723, 
                726, 
                727, 
                729, 
                730, 
                731, 
                736, 
                738, 
                741, 
                745, 
                748, 
                751, 
                756, 
                757, 
                760, 
                768, 
                772, 
                773, 
                774, 
                780, 
                782, 
                785, 
                789, 
                792, 
                795, 
                800
            ]
        }, 
        "xmlValidNormalizeAttributeValue": {
            "code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\nif (doc == NULL) return(NULL);\nif (elem == NULL) return(NULL);\nif (name == NULL) return(NULL);\nif (value == NULL) return(NULL);\nif ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\nxmlChar fn[50];\nreturn(NULL);\nif ((fullname != fn) && (fullname != elem->name))\nxmlFree(fullname);\n}\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\nif (attrDecl == NULL)\nreturn(NULL);\nif (attrDecl->atype == XML_ATTRIBUTE_CDATA)\nreturn(NULL);\nret = xmlStrdup(value);\nreturn(NULL);\nsrc = value;\nwhile (*src == 0x20) src++;\nwhile (*src != 0) {\nif (*src == 0x20) {\nwhile (*src == 0x20) src++;\nif (*src != 0)\n*dst++ = 0x20;\n} else {\n*dst++ = *src++;\n*dst = 0;", 
            "lines": [
                4043, 
                4049, 
                4050, 
                4051, 
                4052, 
                4054, 
                4055, 
                4060, 
                4061, 
                4062, 
                4063, 
                4064, 
                4065, 
                4066, 
                4068, 
                4069, 
                4070, 
                4071, 
                4073, 
                4075, 
                4076, 
                4078, 
                4079, 
                4080, 
                4081, 
                4082, 
                4083, 
                4084, 
                4085, 
                4088
            ]
        }, 
        "xmlValidateAttributeValue2": {
            "code": "xmlValidateAttributeValue2(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nbreak;\nxmlEntityPtr ent;\nif ((ent == NULL) && (doc->standalone == 1)) {\ndoc->standalone = 0;\nif (ent == NULL) {\nxmlErrValidNode(ctxt, (xmlNodePtr) doc,\n} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\nxmlErrValidNode(ctxt, (xmlNodePtr) doc,\nbreak;\nxmlChar *dup, *nam = NULL, *cur, save;\nreturn(0);\ncur = dup;\nwhile (*cur != 0) {\nnam = cur;\nwhile ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\nsave = *cur;\nxmlErrValidNode(ctxt, (xmlNodePtr) doc,\n} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\nxmlErrValidNode(ctxt, (xmlNodePtr) doc,\nif (save == 0)\nbreak;\n*cur = save;\nwhile (IS_BLANK_CH(*cur)) cur++;\nxmlFree(dup);\nxmlNotationPtr nota;\nif ((nota == NULL) && (doc->extSubset != NULL))\nnota = xmlGetDtdNotationDesc(doc->extSubset, value);\nif (nota == NULL) {\nxmlErrValidNode(ctxt, (xmlNodePtr) doc,\nbreak;\nreturn(ret);", 
            "lines": [
                3841, 
                3852, 
                3854, 
                3858, 
                3859, 
                3862, 
                3863, 
                3868, 
                3869, 
                3875, 
                3878, 
                3883, 
                3884, 
                3885, 
                3886, 
                3887, 
                3888, 
                3892, 
                3897, 
                3898, 
                3904, 
                3905, 
                3906, 
                3907, 
                3909, 
                3913, 
                3916, 
                3917, 
                3919, 
                3920, 
                3926, 
                3929
            ]
        }, 
        "xmlValidBuildContentModel": {
            "code": "xmlValidBuildContentModel(xmlValidCtxtPtr ctxt, xmlElementPtr elem) {\nif ((ctxt == NULL) || (elem == NULL))\nreturn(0);\nif (elem->type != XML_ELEMENT_DECL)\nreturn(0);\nif (elem->etype != XML_ELEMENT_TYPE_ELEMENT)\nreturn(1);\nif (elem->contModel != NULL) {\nif (!xmlRegexpIsDeterminist(elem->contModel)) {\nctxt->valid = 0;\nreturn(1);\nctxt->am = xmlNewAutomata();\nxmlErrValidNode(ctxt, (xmlNodePtr) elem,\nctxt->state = xmlAutomataGetInitState(ctxt->am);\nchar expr[5000];\nctxt->state = NULL;", 
            "lines": [
                813, 
                815, 
                816, 
                817, 
                818, 
                819, 
                820, 
                822, 
                823, 
                824, 
                827, 
                830, 
                832, 
                838, 
                843, 
                859
            ]
        }, 
        "xmlValidateOneCdataElement": {
            "code": "xmlValidateOneCdataElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nif ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||\n(elem->type != XML_ELEMENT_NODE))\nreturn(0);\nchild = elem->children;\nwhile (cur != NULL) {\nswitch (cur->type) {\nif ((cur->children != NULL) &&\n(cur->children->children != NULL)) {\nnodeVPush(ctxt, cur);\nbreak;\nbreak;\nret = 0;\ncur = cur->next;\nwhile (cur == NULL) {\ncur = nodeVPop(ctxt);\nbreak;\ncur = cur->next;\nctxt->nodeMax = 0;\nxmlFree(ctxt->nodeTab);\nreturn(ret);", 
            "lines": [
                5516, 
                5521, 
                5522, 
                5523, 
                5525, 
                5528, 
                5529, 
                5535, 
                5536, 
                5537, 
                5541, 
                5546, 
                5548, 
                5554, 
                5555, 
                5556, 
                5558, 
                5559, 
                5563, 
                5566, 
                5569
            ]
        }, 
        "xmlGetDtdQAttrDesc": {
            "code": "xmlGetDtdQAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name,\nif (dtd == NULL) return(NULL);\nif (dtd->attributes == NULL) return(NULL);\ntable = (xmlAttributeTablePtr) dtd->attributes;", 
            "lines": [
                3306, 
                3310, 
                3311, 
                3312
            ]
        }, 
        "xmlGetDtdElementDesc": {
            "code": "xmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {\nif ((dtd == NULL) || (name == NULL)) return(NULL);\nif (dtd->elements == NULL)\nreturn(NULL);\ntable = (xmlElementTablePtr) dtd->elements;\nname = uqname;\ncur = xmlHashLookup2(table, name, prefix);\nif (prefix != NULL) xmlFree(prefix);\nif (uqname != NULL) xmlFree(uqname);\nreturn(cur);", 
            "lines": [
                3147, 
                3152, 
                3153, 
                3154, 
                3155, 
                3159, 
                3160, 
                3161, 
                3162, 
                3163
            ]
        }, 
        "xmlFreeRefList": {
            "code": "xmlFreeRefList(xmlListPtr list_ref) {\nif (list_ref == NULL) return;\nxmlListDelete(list_ref);", 
            "lines": [
                2848, 
                2849, 
                2850
            ]
        }, 
        "xmlDumpAttributeDecl": {
            "code": "xmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {\nif ((buf == NULL) || (attr == NULL))\nreturn;\nxmlBufferWriteChar(buf, \"<!ATTLIST \");\nxmlBufferWriteCHAR(buf, attr->prefix);\nxmlBufferWriteCHAR(buf, attr->name);\nxmlBufferWriteChar(buf, \" CDATA\");\nxmlBufferWriteChar(buf, \" ID\");\nxmlBufferWriteChar(buf, \" IDREF\");\nxmlBufferWriteChar(buf, \" IDREFS\");\nxmlBufferWriteChar(buf, \" ENTITY\");\nxmlBufferWriteChar(buf, \" ENTITIES\");\nxmlBufferWriteChar(buf, \" NMTOKEN\");\nxmlBufferWriteChar(buf, \" NMTOKENS\");\nxmlBufferWriteChar(buf, \" (\");\nxmlBufferWriteChar(buf, \" NOTATION (\");\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nswitch (attr->def) {\nbreak;\nxmlBufferWriteChar(buf, \" #REQUIRED\");\nxmlBufferWriteChar(buf, \" #IMPLIED\");\nxmlBufferWriteChar(buf, \" #FIXED\");\nxmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\nif (attr->defaultValue != NULL) {\nxmlBufferWriteChar(buf, \" \");\nxmlBufferWriteChar(buf, \">\\n\");", 
            "lines": [
                2210, 
                2211, 
                2212, 
                2213, 
                2217, 
                2220, 
                2223, 
                2226, 
                2229, 
                2232, 
                2235, 
                2238, 
                2241, 
                2244, 
                2247, 
                2251, 
                2255, 
                2259, 
                2261, 
                2263, 
                2266, 
                2269, 
                2272, 
                2276, 
                2277, 
                2280
            ]
        }, 
        "xmlGetDtdElementDesc2": {
            "code": "xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name, int create) {\nif (dtd == NULL) return(NULL);\nif (dtd->elements == NULL) {\nxmlDictPtr dict = NULL;\ndict = dtd->doc->dict;\nif (!create)\nreturn(NULL);\ntable = (xmlElementTablePtr) dtd->elements;\ntable = xmlHashCreateDict(0, dict);\nif (table == NULL) {\nxmlVErrMemory(NULL, \"element table allocation failed\");\n}\ntable = (xmlElementTablePtr) dtd->elements;\nname = uqname;\ncur = xmlHashLookup2(table, name, prefix);\nif ((cur == NULL) && (create)) {\ncur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\nxmlVErrMemory(NULL, \"malloc failed\");\nmemset(cur, 0, sizeof(xmlElement));\nif (prefix != NULL) xmlFree(prefix);\nif (uqname != NULL) xmlFree(uqname);\nreturn(cur);", 
            "lines": [
                3177, 
                3182, 
                3183, 
                3184, 
                3187, 
                3189, 
                3190, 
                3194, 
                3196, 
                3199, 
                3200, 
                3203, 
                3204, 
                3208, 
                3209, 
                3210, 
                3211, 
                3213, 
                3216, 
                3228, 
                3229, 
                3230
            ]
        }, 
        "xmlIsID": {
            "code": "xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\nif ((attr == NULL) || (attr->name == NULL)) return(0);\nif ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&\n(!strcmp((char *) attr->name, \"id\")) &&\n(!strcmp((char *) attr->ns->prefix, \"xml\")))\nreturn(1);\nif (doc == NULL) return(0);\nif ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&\n(doc->type != XML_HTML_DOCUMENT_NODE)) {\nreturn(0);\n} else if (doc->type == XML_HTML_DOCUMENT_NODE) {\nif ((xmlStrEqual(BAD_CAST \"id\", attr->name)) ||\n((xmlStrEqual(BAD_CAST \"name\", attr->name)) &&\n((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST \"a\")))))\nreturn(1);\nreturn(0);\n} else if (elem == NULL) {\nreturn(0);\nxmlAttributePtr attrDecl = NULL;\nfullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\nxmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n(xmlChar *)elem->name;\nfullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?\nxmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :\n(xmlChar *)attr->name;\nif (fullelemname != NULL && fullattrname != NULL) {\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,\n}\nif ((fullattrname != fattr) && (fullattrname != attr->name))\nxmlFree(fullattrname);\nif ((fullelemname != felem) && (fullelemname != elem->name))\nxmlFree(fullelemname);\nif ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))\nreturn(1);\nreturn(0);", 
            "lines": [
                2675, 
                2676, 
                2677, 
                2678, 
                2679, 
                2680, 
                2681, 
                2682, 
                2683, 
                2684, 
                2685, 
                2686, 
                2687, 
                2688, 
                2689, 
                2690, 
                2691, 
                2692, 
                2694, 
                2699, 
                2700, 
                2701, 
                2703, 
                2704, 
                2705, 
                2707, 
                2708, 
                2710, 
                2711, 
                2713, 
                2715, 
                2716, 
                2717, 
                2718, 
                2720, 
                2721, 
                2723
            ]
        }, 
        "xmlValidateAttributeValueInternal": {
            "code": "xmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,\nreturn(xmlValidateNamesValueInternal(doc, value));\nreturn(xmlValidateNameValueInternal(doc, value));\nreturn(xmlValidateNmtokensValueInternal(doc, value));\nreturn(xmlValidateNmtokenValueInternal(doc, value));\nbreak;\nreturn(1);", 
            "lines": [
                3760, 
                3765, 
                3770, 
                3773, 
                3775, 
                3777, 
                3779
            ]
        }, 
        "xmlDumpEnumeration": {
            "code": "xmlDumpEnumeration(xmlBufferPtr buf, xmlEnumerationPtr cur) {\nif ((buf == NULL) || (cur == NULL))\nreturn;\nxmlBufferWriteCHAR(buf, cur->name);\nxmlBufferWriteChar(buf, \")\");\nxmlBufferWriteChar(buf, \" | \");", 
            "lines": [
                1819, 
                1820, 
                1821, 
                1823, 
                1825, 
                1827
            ]
        }, 
        "xmlDumpAttributeTable": {
            "code": "xmlDumpAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {\nif ((buf == NULL) || (table == NULL))\nreturn;\nxmlHashScan(table, (xmlHashScanner) xmlDumpAttributeDeclScan, buf);", 
            "lines": [
                2303, 
                2304, 
                2305, 
                2306
            ]
        }, 
        "vstateVPush": {
            "code": "vstateVPush(xmlValidCtxtPtr ctxt, xmlElementPtr elemDecl, xmlNodePtr node) {\nif ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {\nctxt->vstateMax = 10;\nxmlVErrMemory(ctxt, \"malloc failed\");\n}\nif (ctxt->vstateNr >= ctxt->vstateMax) {\nxmlValidState *tmp;\nxmlVErrMemory(ctxt, \"realloc failed\");\nctxt->vstateMax *= 2;\nctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr];\nif ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\nif (elemDecl->contModel == NULL)\nxmlValidBuildContentModel(ctxt, elemDecl);\nif (elemDecl->contModel != NULL) {\nxmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\nctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n}\nreturn(ctxt->vstateNr++);", 
            "lines": [
                274, 
                275, 
                276, 
                280, 
                283, 
                285, 
                286, 
                291, 
                294, 
                297, 
                300, 
                301, 
                302, 
                303, 
                305, 
                307, 
                313, 
                314
            ]
        }, 
        "xmlFreeID": {
            "code": "xmlFreeID(xmlIDPtr id) {\nif (id == NULL) return;\nif (id->doc != NULL)\ndict = id->doc->dict;\nif (id->value != NULL)\nDICT_FREE(id->value)\nif (id->name != NULL)\nDICT_FREE(id->name)\nxmlFree(id);", 
            "lines": [
                2550, 
                2553, 
                2555, 
                2556, 
                2558, 
                2559, 
                2560, 
                2561, 
                2562
            ]
        }, 
        "xmlValidGetPotentialChildren": {
            "code": "xmlValidGetPotentialChildren(xmlElementContent *ctree,\nif ((ctree == NULL) || (names == NULL) || (len == NULL))\nreturn(-1);\nif (*len >= max) return(*len);\nswitch (ctree->type) {\nfor (i = 0; i < *len;i++)\nif (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\nnames[(*len)++] = BAD_CAST \"#PCDATA\";\nfor (i = 0; i < *len;i++)\nif (xmlStrEqual(ctree->name, names[i])) return(*len);\nnames[(*len)++] = ctree->name;\nxmlValidGetPotentialChildren(ctree->c1, names, len, max);\nxmlValidGetPotentialChildren(ctree->c1, names, len, max);\nreturn(*len);", 
            "lines": [
                6881, 
                6886, 
                6887, 
                6888, 
                6890, 
                6892, 
                6893, 
                6894, 
                6897, 
                6898, 
                6899, 
                6902, 
                6906, 
                6911
            ]
        }, 
        "vstateVPop": {
            "code": "vstateVPop(xmlValidCtxtPtr ctxt) {\nif (ctxt->vstateNr < 1) return(-1);\nctxt->vstateNr--;\nif ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\nxmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\nctxt->vstateTab[ctxt->vstateNr].exec = NULL;\nctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\nctxt->vstate = NULL;\nreturn(ctxt->vstateNr);", 
            "lines": [
                318, 
                321, 
                322, 
                326, 
                327, 
                329, 
                331, 
                333, 
                334
            ]
        }, 
        "xmlAddElementDecl": {
            "code": "xmlAddElementDecl(xmlValidCtxtPtr ctxt,\nreturn(NULL);\nif (name == NULL) {\nreturn(NULL);\nswitch (type) {\nif (content != NULL) {\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nbreak;\nif (content != NULL) {\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nbreak;\nif (content == NULL) {\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nbreak;\nif (content == NULL) {\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nbreak;\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nuqname = xmlSplitQName2(name, &ns);\nname = uqname;\ntable = (xmlElementTablePtr) dtd->elements;\nxmlDictPtr dict = NULL;\ndict = dtd->doc->dict;\ntable = xmlHashCreateDict(0, dict);\nif (table == NULL) {\nxmlVErrMemory(ctxt,\nxmlFree(uqname);\nif (ns != NULL)\nxmlFree(ns);\nreturn(NULL);\nif ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {\nret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);\nif ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\noldAttributes = ret->attributes;\n}\nret = xmlHashLookup2(table, name, ns);\nif (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\nxmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\nxmlFree(uqname);\nif (ns != NULL)\nxmlFree(ns);\nreturn(NULL);\nif (ns != NULL) {\nxmlFree(ns);\n} else {\nret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\nxmlVErrMemory(ctxt, \"malloc failed\");\nxmlFree(uqname);\nif (ns != NULL)\nxmlFree(ns);\nreturn(NULL);\nmemset(ret, 0, sizeof(xmlElement));\nxmlVErrMemory(ctxt, \"malloc failed\");\nxmlFree(uqname);\nif (ns != NULL)\nxmlFree(ns);\nxmlFree(ret);\nret->prefix = ns;\nxmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\nxmlFree(uqname);\nreturn(NULL);\nret->attributes = oldAttributes;\nret->etype = type;\n((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n(ctxt->finishDtd == XML_CTXT_FINISH_DTD_1))) {\nret->content = content;\ncontent->parent = (xmlElementContentPtr) 1;\n} else {\nret->content = xmlCopyDocElementContent(dtd->doc, content);\nret->parent = dtd;\ndtd->children = dtd->last = (xmlNodePtr) ret;\ndtd->last->next = (xmlNodePtr) ret;\nif (uqname != NULL)\nxmlFree(uqname);\nreturn(ret);", 
            "lines": [
                1381, 
                1391, 
                1393, 
                1394, 
                1397, 
                1399, 
                1400, 
                1405, 
                1407, 
                1408, 
                1413, 
                1415, 
                1416, 
                1421, 
                1423, 
                1424, 
                1429, 
                1431, 
                1440, 
                1442, 
                1447, 
                1449, 
                1452, 
                1453, 
                1456, 
                1457, 
                1460, 
                1461, 
                1462, 
                1463, 
                1470, 
                1471, 
                1472, 
                1473, 
                1478, 
                1484, 
                1486, 
                1491, 
                1496, 
                1497, 
                1498, 
                1499, 
                1501, 
                1502, 
                1505, 
                1506, 
                1508, 
                1510, 
                1511, 
                1512, 
                1513, 
                1515, 
                1523, 
                1525, 
                1526, 
                1527, 
                1528, 
                1531, 
                1542, 
                1548, 
                1549, 
                1555, 
                1561, 
                1568, 
                1569, 
                1570, 
                1572, 
                1573, 
                1574, 
                1580, 
                1583, 
                1585, 
                1589, 
                1590, 
                1591
            ]
        }, 
        "xmlGetDtdNotationDesc": {
            "code": "xmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {\nif (dtd == NULL) return(NULL);\nif (dtd->notations == NULL) return(NULL);\ntable = (xmlNotationTablePtr) dtd->notations;", 
            "lines": [
                3328, 
                3331, 
                3332, 
                3333
            ]
        }, 
        "xmlValidateNmtokensValueInternal": {
            "code": "xmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {\nif (value == NULL) return(0);\ncur = value;\nwhile (IS_BLANK(val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (!xmlIsDocNameChar(doc, val))\nreturn(0);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (val == 0x20) {\nwhile (val == 0x20) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (val == 0) return(1);\nif (!xmlIsDocNameChar(doc, val))\nreturn(0);\nval = xmlStringCurrentChar(NULL, cur, &len);\nwhile (xmlIsDocNameChar(doc, val)) {\nval = xmlStringCurrentChar(NULL, cur, &len);\nif (val != 0) return(0);\nreturn(1);", 
            "lines": [
                3662, 
                3666, 
                3667, 
                3671, 
                3672, 
                3676, 
                3677, 
                3679, 
                3680, 
                3685, 
                3686, 
                3687, 
                3690, 
                3692, 
                3693, 
                3695, 
                3698, 
                3699, 
                3704, 
                3706
            ]
        }, 
        "xmlValidatePushElement": {
            "code": "xmlValidatePushElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nreturn(0);\nif ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\nxmlValidStatePtr state = ctxt->vstate;\nelemDecl = state->elemDecl;\nret = 0;\nxmlErrValidNode(ctxt, state->node,\nbreak;\nif ((elemDecl->content != NULL) &&\n(elemDecl->content->type ==\nxmlErrValidNode(ctxt, state->node,\nret = xmlValidateCheckMixed(ctxt, elemDecl->content,\nxmlErrValidNode(ctxt, state->node,\nbreak;\nif (state->exec != NULL) {\nret = xmlRegExecPushString(state->exec, qname, NULL);\nxmlErrValidNode(ctxt, state->node,\nret = 1;\n}\nbreak;\n}\n}\neDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);", 
            "lines": [
                5714, 
                5721, 
                5723, 
                5724, 
                5731, 
                5735, 
                5738, 
                5746, 
                5749, 
                5750, 
                5752, 
                5758, 
                5761, 
                5767, 
                5775, 
                5776, 
                5778, 
                5784, 
                5786, 
                5787, 
                5789, 
                5790, 
                5791
            ]
        }, 
        "xmlIsRef": {
            "code": "xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\nreturn(0);\nif (doc == NULL) {\ndoc = attr->doc;\nif (doc == NULL) return(0);\n}\nif ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\nreturn(0);\n} else if (doc->type == XML_HTML_DOCUMENT_NODE) {\nreturn(0);\nxmlAttributePtr attrDecl;\nif (elem == NULL) return(0);\nattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);\nif ((attrDecl == NULL) && (doc->extSubset != NULL))\nattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\nif ((attrDecl != NULL) &&\n(attrDecl->atype == XML_ATTRIBUTE_IDREF ||\nattrDecl->atype == XML_ATTRIBUTE_IDREFS))\nreturn(1);\nreturn(0);", 
            "lines": [
                3015, 
                3017, 
                3018, 
                3019, 
                3020, 
                3021, 
                3023, 
                3024, 
                3025, 
                3027, 
                3029, 
                3031, 
                3032, 
                3033, 
                3034, 
                3037, 
                3038, 
                3039, 
                3040, 
                3042
            ]
        }, 
        "xmlAddID": {
            "code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\nreturn(NULL);\nif (value == NULL) {\nreturn(NULL);\nif (attr == NULL) {\nreturn(NULL);\ntable = (xmlIDTablePtr) doc->ids;\ndoc->ids = table = xmlHashCreateDict(0, doc->dict);\nif (table == NULL) {\nxmlVErrMemory(ctxt,\nret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\nxmlVErrMemory(ctxt, \"malloc failed\");\nret->value = xmlStrdup(value);\nif ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\nif (doc->dict != NULL)\nret->name = xmlDictLookup(doc->dict, attr->name, -1);\nret->name = xmlStrdup(attr->name);\nret->attr = NULL;\nret->attr = attr;\nret->lineno = xmlGetLineNo(attr->parent);\nif (ctxt != NULL) {\nxmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\nxmlFreeID(ret);\nif (attr != NULL)\nattr->atype = XML_ATTRIBUTE_ID;\nreturn(ret);", 
            "lines": [
                2578, 
                2584, 
                2586, 
                2587, 
                2589, 
                2590, 
                2596, 
                2598, 
                2600, 
                2601, 
                2606, 
                2608, 
                2615, 
                2617, 
                2621, 
                2622, 
                2624, 
                2625, 
                2627, 
                2630, 
                2637, 
                2638, 
                2642, 
                2645, 
                2646, 
                2647
            ]
        }, 
        "xmlValidateAttributeCallback": {
            "code": "xmlValidateAttributeCallback(xmlAttributePtr cur, xmlValidCtxtPtr ctxt,\nreturn;\nswitch (cur->atype) {\nbreak;\nif (cur->defaultValue != NULL) {\nret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\nif ((ret == 0) && (ctxt->valid == 1))\nctxt->valid = 0;\n}\nif (cur->tree != NULL) {\nxmlEnumerationPtr tree = cur->tree;\nwhile (tree != NULL) {\nret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\nif ((ret == 0) && (ctxt->valid == 1))\nctxt->valid = 0;\ntree = tree->next;\n}\n}\nif (cur->atype == XML_ATTRIBUTE_NOTATION) {\ndoc = cur->doc;\nxmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\nif (doc != NULL)\nelem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);\nif ((elem == NULL) && (doc != NULL))\nelem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);\nif ((elem == NULL) && (cur->parent != NULL) &&\n(cur->parent->type == XML_DTD_NODE))\nelem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);\nif (elem == NULL) {\nxmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\nif (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\nxmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n}", 
            "lines": [
                6667, 
                6674, 
                6675, 
                6683, 
                6687, 
                6689, 
                6691, 
                6692, 
                6693, 
                6694, 
                6695, 
                6696, 
                6697, 
                6699, 
                6700, 
                6701, 
                6703, 
                6704, 
                6705, 
                6706, 
                6708, 
                6714, 
                6715, 
                6716, 
                6717, 
                6718, 
                6719, 
                6720, 
                6721, 
                6722, 
                6727, 
                6728, 
                6733
            ]
        }, 
        "xmlCopyEnumeration": {
            "code": "xmlCopyEnumeration(xmlEnumerationPtr cur) {\nif (cur == NULL) return(NULL);\nret = xmlCreateEnumeration((xmlChar *) cur->name);\nif (ret == NULL) return(NULL);\nif (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\nelse ret->next = NULL;\nreturn(ret);", 
            "lines": [
                1796, 
                1799, 
                1800, 
                1801, 
                1803, 
                1804, 
                1806
            ]
        }, 
        "xmlValidateDtd": {
            "code": "xmlValidateDtd(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlDtdPtr dtd) {\nif (dtd == NULL) return(0);\nif (doc == NULL) return(0);\noldExt = doc->extSubset;\ndoc->extSubset = oldExt;\nif (doc->ids != NULL) {\nxmlFreeIDTable(doc->ids);\nif (doc->refs != NULL) {\nxmlFreeRefTable(doc->refs);\nroot = xmlDocGetRootElement(doc);", 
            "lines": [
                6614, 
                6619, 
                6620, 
                6621, 
                6627, 
                6631, 
                6632, 
                6635, 
                6636, 
                6639
            ]
        }, 
        "xmlDumpNotationTable": {
            "code": "xmlDumpNotationTable(xmlBufferPtr buf, xmlNotationTablePtr table) {\nif ((buf == NULL) || (table == NULL))\nreturn;\nxmlHashScan(table, (xmlHashScanner) xmlDumpNotationDeclScan, buf);", 
            "lines": [
                2519, 
                2520, 
                2521, 
                2522
            ]
        }, 
        "xmlValidateRef": {
            "code": "xmlValidateRef(xmlRefPtr ref, xmlValidCtxtPtr ctxt,\nreturn;\nif ((ref->attr == NULL) && (ref->name == NULL))\nreturn;\nattr = ref->attr;\nxmlChar *dup, *str = NULL, *cur, save;\nctxt->valid = 0;\ncur = dup;\nwhile (*cur != 0) {\nstr = cur;\nwhile ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\nsave = *cur;\nxmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\nif (save == 0)\nbreak;\n*cur = save;\nwhile (IS_BLANK_CH(*cur)) cur++;\nxmlFree(dup);\n} else if (attr->atype == XML_ATTRIBUTE_IDREF) {\nid = xmlGetID(ctxt->doc, name);\nxmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n} else if (attr->atype == XML_ATTRIBUTE_IDREFS) {\nxmlChar *dup, *str = NULL, *cur, save;\nxmlVErrMemory(ctxt, \"IDREFS split\");\ncur = dup;\nwhile (*cur != 0) {\nstr = cur;\nwhile ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\nsave = *cur;\nxmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\nif (save == 0)\nbreak;\n*cur = save;\nwhile (IS_BLANK_CH(*cur)) cur++;\nxmlFree(dup);", 
            "lines": [
                6435, 
                6441, 
                6442, 
                6443, 
                6444, 
                6446, 
                6450, 
                6453, 
                6454, 
                6455, 
                6456, 
                6457, 
                6461, 
                6466, 
                6467, 
                6468, 
                6469, 
                6471, 
                6472, 
                6473, 
                6475, 
                6480, 
                6481, 
                6485, 
                6489, 
                6490, 
                6491, 
                6492, 
                6493, 
                6497, 
                6502, 
                6503, 
                6504, 
                6505, 
                6507
            ]
        }
    }, 
    "c14n.c": {
        "xmlC14NNewCtx": {
            "code": "xmlC14NNewCtx(xmlDocPtr doc,\nif ((doc == NULL) || (buf == NULL)) {\nxmlC14NErrParam(\"creating new context\");\nif (buf->encoder != NULL) {\nxmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,\nif (doc->charset != XML_CHAR_ENCODING_UTF8) {\nxmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,\nctx = (xmlC14NCtxPtr) xmlMalloc(sizeof(xmlC14NCtx));\nxmlC14NErrMemory(\"creating context\");\nmemset(ctx, 0, sizeof(xmlC14NCtx));\nxmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_CREATE_STACK,\nctx->mode = mode;\nctx->inclusive_ns_prefixes = inclusive_ns_prefixes;\nreturn (ctx);", 
            "lines": [
                1774, 
                1781, 
                1782, 
                1789, 
                1790, 
                1798, 
                1799, 
                1807, 
                1809, 
                1812, 
                1827, 
                1837, 
                1839, 
                1841
            ]
        }, 
        "xmlC14NProcessNodeList": {
            "code": "xmlC14NProcessNodeList(xmlC14NCtxPtr ctx, xmlNodePtr cur)\nxmlC14NErrParam(\"processing node list\");\nfor (ret = 0; cur != NULL && ret >= 0; cur = cur->next) {\nret = xmlC14NProcessNode(ctx, cur);\nreturn (ret);", 
            "lines": [
                1715, 
                1720, 
                1724, 
                1725, 
                1727
            ]
        }, 
        "xmlC14NFixupBaseAttr": {
            "code": "xmlC14NFixupBaseAttr(xmlC14NCtxPtr ctx, xmlAttrPtr xml_base_attr)\nif ((ctx == NULL) || (xml_base_attr == NULL) || (xml_base_attr->parent == NULL)) {\nxmlC14NErrParam(\"processing xml:base attribute\");\nres = xmlNodeListGetString(ctx->doc, xml_base_attr->children, 1);\nxmlC14NErrInternal(\"processing xml:base attribute - can't get attr value\");\ncur = xml_base_attr->parent->parent;\nwhile((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {\nattr = xmlHasNsProp(cur, BAD_CAST \"base\", XML_XML_NAMESPACE);\ntmp_str = xmlNodeListGetString(ctx->doc, attr->children, 1);\nxmlFree(res);\ntmp_str_len = xmlStrlen(tmp_str);\nif(tmp_str_len > 1 && tmp_str[tmp_str_len - 2] == '.') {\ntmp_str2 = xmlStrcat(tmp_str, BAD_CAST \"/\");\nxmlFree(tmp_str);\ntmp_str = tmp_str2;\ntmp_str2 = xmlBuildURI(res, tmp_str);\nxmlFree(tmp_str);\nxmlFree(tmp_str);\ncur = cur->parent;\nif((res == NULL) || xmlStrEqual(res, BAD_CAST \"\")) {\nxmlFree(res);\nattr = xmlNewNsProp(NULL, xml_base_attr->ns, BAD_CAST \"base\", res);\nxmlFree(res);\nxmlFree(res);", 
            "lines": [
                1001, 
                1010, 
                1011, 
                1016, 
                1018, 
                1023, 
                1024, 
                1025, 
                1028, 
                1030, 
                1038, 
                1039, 
                1040, 
                1042, 
                1049, 
                1053, 
                1055, 
                1063, 
                1069, 
                1073, 
                1074, 
                1079, 
                1081, 
                1088
            ]
        }, 
        "xmlC14NVisibleNsStackShift": {
            "code": "xmlC14NVisibleNsStackShift(xmlC14NVisibleNsStackPtr cur) {\nxmlC14NErrParam(\"shifting namespaces stack\");\ncur->nsPrevStart = cur->nsPrevEnd;", 
            "lines": [
                383, 
                385, 
                388
            ]
        }, 
        "xmlC11NNormalizeString": {
            "code": "xmlC11NNormalizeString(const xmlChar * input,\nreturn (NULL);\nbuffer_size = 1000;\nxmlC14NErrMemory(\"allocating buffer\");\nout = buffer;\nwhile (*cur != '\\0') {\nif ((out - buffer) > (buffer_size - 10)) {\nint indx = out - buffer;\ngrowBufferReentrant();\nout = &buffer[indx];\nif ((*cur == '<') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n(mode == XMLC14N_NORMALIZE_TEXT))) {\n*out++ = '&';\n} else if ((*cur == '>') && (mode == XMLC14N_NORMALIZE_TEXT)) {\n*out++ = '&';\n} else if ((*cur == '&') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n(mode == XMLC14N_NORMALIZE_TEXT))) {\n*out++ = '&';\n} else if ((*cur == '\"') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n*out++ = '&';\n} else if ((*cur == '\\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n*out++ = '&';\n} else if ((*cur == '\\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {\n*out++ = '&';\n} else if ((*cur == '\\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||\n(mode == XMLC14N_NORMALIZE_TEXT) ||\n(mode == XMLC14N_NORMALIZE_COMMENT) ||\n(mode == XMLC14N_NORMALIZE_PI))) {\n*out++ = '&';\n*out++ = *cur;\ncur++;\n*out = 0;", 
            "lines": [
                2147, 
                2156, 
                2161, 
                2164, 
                2167, 
                2169, 
                2170, 
                2171, 
                2173, 
                2174, 
                2177, 
                2178, 
                2179, 
                2183, 
                2184, 
                2188, 
                2189, 
                2190, 
                2195, 
                2196, 
                2202, 
                2203, 
                2208, 
                2209, 
                2214, 
                2215, 
                2216, 
                2217, 
                2218, 
                2228, 
                2230, 
                2232
            ]
        }, 
        "xmlC14NFindHiddenParentAttr": {
            "code": "xmlC14NFindHiddenParentAttr(xmlC14NCtxPtr ctx, xmlNodePtr cur, const xmlChar * name, const xmlChar * ns)\nwhile((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {\nres = xmlHasNsProp(cur, name, ns);\nreturn res;\ncur = cur->parent;\nreturn NULL;", 
            "lines": [
                978, 
                981, 
                982, 
                984, 
                987, 
                990
            ]
        }, 
        "xmlC14NAttrsCompare": {
            "code": "xmlC14NAttrsCompare(xmlAttrPtr attr1, xmlAttrPtr attr2)\nreturn (0);\nif (attr1 == NULL)\nreturn (-1);\nif (attr2 == NULL)\nreturn (1);\nif (attr1->ns == attr2->ns) {\nreturn (xmlStrcmp(attr1->name, attr2->name));\nif (attr1->ns == NULL)\nreturn (-1);\nif (attr2->ns == NULL)\nreturn (1);\nif (attr1->ns->prefix == NULL)\nreturn (-1);\nif (attr2->ns->prefix == NULL)\nreturn (1);\nret = xmlStrcmp(attr1->ns->href, attr2->ns->href);\nret = xmlStrcmp(attr1->name, attr2->name);\nreturn (ret);", 
            "lines": [
                882, 
                890, 
                891, 
                892, 
                893, 
                894, 
                895, 
                896, 
                904, 
                905, 
                906, 
                907, 
                908, 
                909, 
                910, 
                911, 
                913, 
                915, 
                917
            ]
        }, 
        "xmlC14NVisibleNsStackFind": {
            "code": "xmlC14NVisibleNsStackFind(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns)\nxmlC14NErrParam(\"searching namespaces stack (c14n)\");\nprefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST \"\" : ns->prefix;\nhref = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST \"\" : ns->href;\nhas_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));\nint start = (has_empty_ns) ? 0 : cur->nsPrevStart;\nfor (i = cur->nsCurEnd - 1; i >= start; --i) {\nxmlNsPtr ns1 = cur->nsTab[i];\nif(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {\nreturn(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL));\n}\n}\nreturn(has_empty_ns);", 
            "lines": [
                413, 
                421, 
                429, 
                430, 
                431, 
                434, 
                435, 
                436, 
                438, 
                439, 
                441, 
                442, 
                443
            ]
        }, 
        "xmlC14NVisibleNsStackRestore": {
            "code": "xmlC14NVisibleNsStackRestore(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {\nif((cur == NULL) || (state == NULL)) {\nxmlC14NErrParam(\"restoring namespaces stack\");\ncur->nsCurEnd = state->nsCurEnd;", 
            "lines": [
                372, 
                373, 
                374, 
                377
            ]
        }, 
        "xmlExcC14NVisibleNsStackFind": {
            "code": "xmlExcC14NVisibleNsStackFind(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlC14NCtxPtr ctx) {\nxmlC14NErrParam(\"searching namespaces stack (exc c14n)\");\nprefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST \"\" : ns->prefix;\nhref = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST \"\" : ns->href;\nhas_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));\nint start = 0;\nfor (i = cur->nsCurEnd - 1; i >= start; --i) {\nxmlNsPtr ns1 = cur->nsTab[i];\nif(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {\nif(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL)) {\nreturn(xmlC14NIsVisible(ctx, ns1, cur->nodeTab[i]));\nreturn(0);\n}\n}\nreturn(has_empty_ns);", 
            "lines": [
                447, 
                454, 
                462, 
                463, 
                464, 
                467, 
                468, 
                469, 
                471, 
                472, 
                473, 
                475, 
                478, 
                479, 
                480
            ]
        }, 
        "xmlC14NProcessAttrsAxis": {
            "code": "xmlC14NProcessAttrsAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int parent_visible)\nif ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\nxmlC14NErrParam(\"processing attributes axis\");\nlist = xmlListCreate(NULL, (xmlListDataCompare) xmlC14NAttrsCompare);\nxmlC14NErrInternal(\"creating attributes list\");\nswitch(ctx->mode) {\nattr = cur->properties;\nwhile (attr != NULL) {\nif (xmlC14NIsVisible(ctx, attr, cur)) {\nxmlListInsert(list, attr);\nattr = attr->next;\nif (parent_visible && (cur->parent != NULL) &&\n(!xmlC14NIsVisible(ctx, cur->parent, cur->parent->parent)))\nxmlNodePtr tmp;\nwhile (tmp != NULL) {\nattr = tmp->properties;\nwhile (attr != NULL) {\nif (xmlC14NIsXmlAttr(attr) != 0) {\nif (xmlListSearch(list, attr) == NULL) {\nxmlListInsert(list, attr);\n}\nattr = attr->next;\ntmp = tmp->parent;\n}\nbreak;\nattr = cur->properties;\nwhile (attr != NULL) {\nif (xmlC14NIsVisible(ctx, attr, cur)) {\nxmlListInsert(list, attr);\nattr = attr->next;\nbreak;\nattr = cur->properties;\nwhile (attr != NULL) {\nif ((!parent_visible) || (xmlC14NIsXmlAttr(attr) == 0)) {\nif (xmlC14NIsVisible(ctx, attr, cur)) {\nxmlListInsert(list, attr);\n} else {\nint matched = 0;\nif((!matched) && (xml_lang_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"lang\")) {\nxml_lang_attr = attr;\nif((!matched) && (xml_space_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"space\")) {\nxml_space_attr = attr;\nif((!matched) && (xml_base_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST \"base\")) {\nxml_base_attr = attr;\nif((!matched) && xmlC14NIsVisible(ctx, attr, cur)) {\nxmlListInsert(list, attr);\nattr = attr->next;\nif ((parent_visible)) {\nif(xml_lang_attr == NULL) {\nxml_lang_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"lang\", XML_XML_NAMESPACE);\nif(xml_lang_attr != NULL) {\nxmlListInsert(list, xml_lang_attr);\nif(xml_space_attr == NULL) {\nxml_space_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"space\", XML_XML_NAMESPACE);\nif(xml_space_attr != NULL) {\nxmlListInsert(list, xml_space_attr);\nif(xml_base_attr == NULL) {\nxml_base_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST \"base\", XML_XML_NAMESPACE);\nif(xml_base_attr != NULL) {\nxml_base_attr = xmlC14NFixupBaseAttr(ctx, xml_base_attr);\nxmlListInsert(list, xml_base_attr);\n}\n}\nbreak;\nxmlListWalk(list, (xmlListWalker) xmlC14NPrintAttrs, (const void *) ctx);", 
            "lines": [
                1126, 
                1137, 
                1138, 
                1145, 
                1147, 
                1151, 
                1167, 
                1168, 
                1170, 
                1171, 
                1173, 
                1179, 
                1180, 
                1182, 
                1189, 
                1190, 
                1191, 
                1192, 
                1193, 
                1194, 
                1196, 
                1197, 
                1199, 
                1201, 
                1204, 
                1213, 
                1214, 
                1216, 
                1217, 
                1219, 
                1223, 
                1256, 
                1257, 
                1259, 
                1261, 
                1262, 
                1264, 
                1265, 
                1268, 
                1269, 
                1272, 
                1273, 
                1278, 
                1279, 
                1284, 
                1285, 
                1290, 
                1294, 
                1297, 
                1298, 
                1300, 
                1301, 
                1303, 
                1304, 
                1306, 
                1307, 
                1311, 
                1313, 
                1315, 
                1316, 
                1318, 
                1324, 
                1325, 
                1328, 
                1334
            ]
        }, 
        "xmlC14NStrEqual": {
            "code": "xmlC14NStrEqual(const xmlChar *str1, const xmlChar *str2) {\nif (str1 == str2) return(1);\nif (str1 == NULL) return((*str2) == '\\0');\nif (str2 == NULL) return((*str1) == '\\0');\ndo {\nif (*str1++ != *str2) return(0);\n} while (*str2++);\nreturn(1);", 
            "lines": [
                393, 
                394, 
                395, 
                396, 
                397, 
                398, 
                399, 
                400
            ]
        }, 
        "xmlExcC14NProcessNamespacesAxis": {
            "code": "xmlExcC14NProcessNamespacesAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\nif ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\nxmlC14NErrParam(\"processing namespaces axis (exc c14n)\");\nif(!xmlC14NIsExclusive(ctx)) {\nxmlC14NErrParam(\"processing namespaces axis (exc c14n)\");\nlist = xmlListCreate(NULL, (xmlListDataCompare) xmlC14NNsCompare);\nxmlC14NErrInternal(\"creating namespaces list (exc c14n)\");\nif(ctx->inclusive_ns_prefixes != NULL) {\nxmlChar *prefix;\nfor (i = 0; ctx->inclusive_ns_prefixes[i] != NULL; ++i) {\nprefix = ctx->inclusive_ns_prefixes[i];\n|| xmlStrEqual(prefix, BAD_CAST \"\")) {\nprefix = NULL;\nns = xmlSearchNs(cur->doc, cur, prefix);\nif((ns != NULL) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {\nalready_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);\nxmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);\nif(!already_rendered) {\nxmlListInsert(list, ns);\nif(xmlStrlen(ns->prefix) == 0) {\nhas_empty_ns = 1;\n}\n}\n}\nif(cur->ns != NULL) {\nns = cur->ns;\nns = xmlSearchNs(cur->doc, cur, NULL);\nif((ns != NULL) && !xmlC14NIsXmlNs(ns)) {\nif(visible && xmlC14NIsVisible(ctx, ns, cur)) {\nif(!xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, ns, ctx)) {\nxmlListInsert(list, ns);\n}\nif(visible) {\nxmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);\nif(xmlStrlen(ns->prefix) == 0) {\nhas_empty_ns = 1;\n}\nfor(attr = cur->properties; attr != NULL; attr = attr->next) {\nif((attr->ns != NULL) && !xmlC14NIsXmlNs(attr->ns) && xmlC14NIsVisible(ctx, attr, cur)) {\nalready_rendered = xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, attr->ns, ctx);\nif(!already_rendered && visible) {\nxmlListInsert(list, attr->ns);\nif(xmlStrlen(attr->ns->prefix) == 0) {\nhas_empty_ns = 1;\n} else if((attr->ns != NULL) && (xmlStrlen(attr->ns->prefix) == 0) && (xmlStrlen(attr->ns->href) == 0)) {\nhas_visibly_utilized_empty_ns = 1;\n}\nif(visible && has_visibly_utilized_empty_ns &&\n!has_empty_ns && !has_empty_ns_in_inclusive_list) {\nmemset(&ns_default, 0, sizeof(ns_default));\nxmlC14NPrintNamespaces(&ns_default, ctx);\n} else if(visible && !has_empty_ns && has_empty_ns_in_inclusive_list) {\nmemset(&ns_default, 0, sizeof(ns_default));\nxmlC14NPrintNamespaces(&ns_default, ctx);\n}\nxmlListWalk(list, (xmlListWalker) xmlC14NPrintNamespaces, (const void *) ctx);", 
            "lines": [
                707, 
                717, 
                718, 
                722, 
                723, 
                731, 
                733, 
                742, 
                743, 
                746, 
                747, 
                752, 
                753, 
                757, 
                758, 
                759, 
                761, 
                763, 
                764, 
                766, 
                767, 
                769, 
                770, 
                771, 
                774, 
                775, 
                777, 
                780, 
                781, 
                782, 
                783, 
                785, 
                786, 
                787, 
                789, 
                790, 
                792, 
                796, 
                802, 
                803, 
                805, 
                806, 
                808, 
                809, 
                811, 
                812, 
                814, 
                819, 
                820, 
                823, 
                827, 
                829, 
                832, 
                834, 
                836, 
                843
            ]
        }, 
        "xmlC14NVisibleNsStackCreate": {
            "code": "xmlC14NVisibleNsStackPtr ret;\nxmlC14NErrMemory(\"creating namespaces stack\");\nmemset(ret, 0 , (size_t) sizeof(xmlC14NVisibleNsStack));", 
            "lines": [
                283, 
                287, 
                290
            ]
        }, 
        "xmlC14NErr": {
            "code": "xmlC14NErr(xmlC14NCtxPtr ctxt, xmlNodePtr node, int error,\nctxt->error = error;", 
            "lines": [
                236, 
                240
            ]
        }, 
        "xmlC14NVisibleNsStackSave": {
            "code": "xmlC14NVisibleNsStackSave(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {\nif((cur == NULL) || (state == NULL)) {\nxmlC14NErrParam(\"saving namespaces stack\");\nstate->nsCurEnd = cur->nsCurEnd;", 
            "lines": [
                360, 
                361, 
                362, 
                366
            ]
        }, 
        "xmlC14NProcessNamespacesAxis": {
            "code": "xmlC14NProcessNamespacesAxis(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\nif ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\nxmlC14NErrParam(\"processing namespaces axis (c14n)\");\nlist = xmlListCreate(NULL, (xmlListDataCompare) xmlC14NNsCompare);\nxmlC14NErrInternal(\"creating namespaces list (c14n)\");\nfor(n = cur; n != NULL; n = n->parent) {\nfor(ns = n->nsDef; ns != NULL; ns = ns->next) {\ntmp = xmlSearchNs(cur->doc, cur, ns->prefix);\nif((tmp == ns) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {\nalready_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);\nxmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);\nif(!already_rendered) {\nxmlListInsert(list, ns);\nif(xmlStrlen(ns->prefix) == 0) {\nhas_empty_ns = 1;\n}\n}\n}\nif(visible && !has_empty_ns) {\nmemset(&ns_default, 0, sizeof(ns_default));\nxmlC14NPrintNamespaces(&ns_default, ctx);\n}\nxmlListWalk(list, (xmlListWalker) xmlC14NPrintNamespaces, (const void *) ctx);", 
            "lines": [
                602, 
                610, 
                611, 
                618, 
                620, 
                625, 
                626, 
                627, 
                629, 
                630, 
                632, 
                634, 
                635, 
                637, 
                638, 
                640, 
                641, 
                642, 
                653, 
                656, 
                658, 
                660, 
                666
            ]
        }, 
        "xmlC14NExecute": {
            "code": "xmlC14NExecute(xmlDocPtr doc, xmlC14NIsVisibleCallback is_visible_callback,\nif ((buf == NULL) || (doc == NULL)) {\nxmlC14NErrParam(\"executing c14n\");\nswitch(mode) {\nc14n_mode = (xmlC14NMode)mode;\nxmlC14NErrParam(\"invalid mode for executing c14n\");\nif (buf->encoder != NULL) {\nxmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,\nctx = xmlC14NNewCtx(doc, is_visible_callback, user_data,\nxmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_CREATE_CTXT,\nif (doc->children != NULL) {\nret = xmlC14NProcessNodeList(ctx, doc->children);\nxmlC14NErrInternal(\"processing docs children list\");\n}\nret = xmlOutputBufferFlush(buf);\nxmlC14NErrInternal(\"flushing output buffer\");\nxmlC14NFreeCtx(ctx);", 
            "lines": [
                1868, 
                1876, 
                1877, 
                1883, 
                1887, 
                1890, 
                1897, 
                1898, 
                1903, 
                1907, 
                1922, 
                1923, 
                1925, 
                1929, 
                1934, 
                1936, 
                1944
            ]
        }, 
        "xmlC14NProcessElementNode": {
            "code": "xmlC14NProcessElementNode(xmlC14NCtxPtr ctx, xmlNodePtr cur, int visible)\nif ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\nxmlC14NErrParam(\"processing element node\");\nif (xmlC14NCheckForRelativeNamespaces(ctx, cur) < 0) {\nxmlC14NErrInternal(\"checking for relative namespaces\");\nmemset(&state, 0, sizeof(state));\nif (ctx->parent_is_doc) {\nparent_is_doc = ctx->parent_is_doc;\nxmlOutputBufferWriteString(ctx->buf, \"<\");\nif ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {\nxmlOutputBufferWriteString(ctx->buf,\nxmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);\nif (!xmlC14NIsExclusive(ctx)) {\nret = xmlC14NProcessNamespacesAxis(ctx, cur, visible);\nret = xmlExcC14NProcessNamespacesAxis(ctx, cur, visible);\nif (ret < 0) {\nxmlC14NErrInternal(\"processing namespaces axis\");\nif(visible) {\nxmlC14NVisibleNsStackShift(ctx->ns_rendered);\nret = xmlC14NProcessAttrsAxis(ctx, cur, visible);\nxmlC14NErrInternal(\"processing attributes axis\");\nif (visible) {\nxmlOutputBufferWriteString(ctx->buf, \">\");\nif (cur->children != NULL) {\nret = xmlC14NProcessNodeList(ctx, cur->children);\nxmlC14NErrInternal(\"processing childrens list\");\n}\nif (visible) {\nxmlOutputBufferWriteString(ctx->buf, \"</\");\nif ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {\nxmlOutputBufferWriteString(ctx->buf,\nxmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);\nctx->parent_is_doc = parent_is_doc;\n}\nxmlC14NVisibleNsStackRestore(ctx->ns_rendered, &state);", 
            "lines": [
                1416, 
                1422, 
                1423, 
                1432, 
                1433, 
                1441, 
                1445, 
                1447, 
                1451, 
                1453, 
                1454, 
                1458, 
                1461, 
                1462, 
                1464, 
                1466, 
                1467, 
                1471, 
                1472, 
                1475, 
                1477, 
                1481, 
                1482, 
                1484, 
                1485, 
                1487, 
                1490, 
                1491, 
                1492, 
                1493, 
                1494, 
                1498, 
                1502, 
                1505, 
                1510
            ]
        }, 
        "xmlC14NIsXmlNs": {
            "code": "xmlC14NIsXmlNs(xmlNsPtr ns)\n(xmlStrEqual(ns->prefix, BAD_CAST \"xml\")) &&\n(xmlStrEqual(ns->href, XML_XML_NAMESPACE)));", 
            "lines": [
                498, 
                501, 
                502
            ]
        }, 
        "xmlC14NDocDumpMemory": {
            "code": "xmlC14NDocDumpMemory(xmlDocPtr doc, xmlNodeSetPtr nodes,\nxmlC14NErrParam(\"dumping doc to memory\");\n*doc_txt_ptr = NULL;\nxmlC14NErrMemory(\"creating output buffer\");\nret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,\nxmlC14NErrInternal(\"saving doc to output buffer\");\nret = xmlBufUse(buf->buffer);\n*doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), ret);\n(void) xmlOutputBufferClose(buf);\nif ((*doc_txt_ptr == NULL) && (ret > 0)) {\nxmlC14NErrMemory(\"coping canonicanized document\");\nreturn (ret);", 
            "lines": [
                2005, 
                2013, 
                2017, 
                2024, 
                2031, 
                2034, 
                2039, 
                2041, 
                2043, 
                2045, 
                2046, 
                2049
            ]
        }, 
        "xmlC14NCheckForRelativeNamespaces": {
            "code": "xmlC14NCheckForRelativeNamespaces(xmlC14NCtxPtr ctx, xmlNodePtr cur)\nif ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {\nxmlC14NErrParam(\"checking for relative namespaces\");\nns = cur->nsDef;\nwhile (ns != NULL) {\nif (xmlStrlen(ns->href) > 0) {\nxmlURIPtr uri;\nxmlC14NErrInternal(\"parsing namespace uri\");\nif (xmlStrlen((const xmlChar *) uri->scheme) == 0) {\nxmlC14NErrRelativeNamespace(uri->scheme);\nif ((xmlStrcasecmp((const xmlChar *) uri->scheme, BAD_CAST \"urn\") != 0)\n&& (xmlStrcasecmp((const xmlChar *) uri->scheme, BAD_CAST \"dav\") !=0)\n&& (xmlStrlen((const xmlChar *) uri->server) == 0)) {\nxmlC14NErrRelativeNamespace(uri->scheme);\nxmlFreeURI(uri);\nns = ns->next;\nreturn (0);", 
            "lines": [
                1354, 
                1358, 
                1359, 
                1363, 
                1364, 
                1365, 
                1366, 
                1370, 
                1373, 
                1374, 
                1378, 
                1379, 
                1380, 
                1381, 
                1385, 
                1387, 
                1389
            ]
        }, 
        "xmlC14NProcessNode": {
            "code": "xmlC14NProcessNode(xmlC14NCtxPtr ctx, xmlNodePtr cur)\nif ((ctx == NULL) || (cur == NULL)) {\nxmlC14NErrParam(\"processing node\");\nvisible = xmlC14NIsVisible(ctx, cur, cur->parent);\nret = xmlC14NProcessElementNode(ctx, cur, visible);\nif ((visible) && (cur->content != NULL)) {\nxmlChar *buffer;\nxmlOutputBufferWriteString(ctx->buf,\nxmlC14NErrInternal(\"normalizing text node\");\n}\nbreak;\nif (visible) {\nif (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {\nxmlOutputBufferWriteString(ctx->buf, \"\\x0A<?\");\nxmlOutputBufferWriteString(ctx->buf, \"<?\");\nxmlOutputBufferWriteString(ctx->buf,\nif ((cur->content != NULL) && (*(cur->content) != '\\0')) {\nxmlChar *buffer;\nxmlOutputBufferWriteString(ctx->buf,\nxmlC14NErrInternal(\"normalizing pi node\");\n}\nif (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {\nxmlOutputBufferWriteString(ctx->buf, \"?>\\x0A\");\nxmlOutputBufferWriteString(ctx->buf, \"?>\");\n}\nbreak;\nif (visible && ctx->with_comments) {\nif (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {\nxmlOutputBufferWriteString(ctx->buf, \"\\x0A<!--\");\nxmlOutputBufferWriteString(ctx->buf, \"<!--\");\nif (cur->content != NULL) {\nxmlChar *buffer;\nxmlOutputBufferWriteString(ctx->buf,\nxmlC14NErrInternal(\"normalizing comment node\");\n}\nif (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {\nxmlOutputBufferWriteString(ctx->buf, \"-->\\x0A\");\nxmlOutputBufferWriteString(ctx->buf, \"-->\");\n}\nbreak;\nif (cur->children != NULL) {\nctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;\nbreak;\nxmlC14NErrInvalidNode(\"XML_ATTRIBUTE_NODE\", \"processing node\");\nxmlC14NErrInvalidNode(\"XML_NAMESPACE_DECL\", \"processing node\");\nxmlC14NErrInvalidNode(\"XML_ENTITY_REF_NODE\", \"processing node\");\nxmlC14NErrInvalidNode(\"XML_ENTITY_NODE\", \"processing node\");\nbreak;\nxmlC14NErrUnknownNode(cur->type, \"processing node\");\nreturn (ret);", 
            "lines": [
                1524, 
                1529, 
                1530, 
                1534, 
                1537, 
                1550, 
                1551, 
                1555, 
                1559, 
                1562, 
                1563, 
                1577, 
                1578, 
                1579, 
                1581, 
                1584, 
                1586, 
                1587, 
                1594, 
                1598, 
                1601, 
                1603, 
                1604, 
                1606, 
                1608, 
                1609, 
                1626, 
                1627, 
                1628, 
                1630, 
                1633, 
                1634, 
                1639, 
                1643, 
                1646, 
                1648, 
                1649, 
                1651, 
                1653, 
                1654, 
                1663, 
                1664, 
                1668, 
                1671, 
                1674, 
                1677, 
                1680, 
                1696, 
                1698, 
                1702
            ]
        }, 
        "xmlC14NFreeCtx": {
            "code": "xmlC14NFreeCtx(xmlC14NCtxPtr ctx)\nxmlC14NErrParam(\"freeing context\");\nif (ctx->ns_rendered != NULL) {\nxmlC14NVisibleNsStackDestroy(ctx->ns_rendered);\nxmlFree(ctx);", 
            "lines": [
                1739, 
                1742, 
                1746, 
                1747, 
                1749
            ]
        }, 
        "xmlC14NVisibleNsStackDestroy": {
            "code": "xmlC14NVisibleNsStackDestroy(xmlC14NVisibleNsStackPtr cur) {\nxmlC14NErrParam(\"destroying namespaces stack\");\nif(cur->nsTab != NULL) {\nmemset(cur->nsTab, 0, cur->nsMax * sizeof(xmlNsPtr));\nif(cur->nodeTab != NULL) {\nmemset(cur->nodeTab, 0, cur->nsMax * sizeof(xmlNodePtr));\nmemset(cur, 0, sizeof(xmlC14NVisibleNsStack));", 
            "lines": [
                295, 
                297, 
                300, 
                301, 
                304, 
                305, 
                308
            ]
        }, 
        "xmlC14NNsCompare": {
            "code": "xmlC14NNsCompare(xmlNsPtr ns1, xmlNsPtr ns2)\nreturn (0);\nif (ns1 == NULL)\nreturn (-1);\nif (ns2 == NULL)\nreturn (1);\nreturn (xmlStrcmp(ns1->prefix, ns2->prefix));", 
            "lines": [
                516, 
                519, 
                520, 
                521, 
                522, 
                523, 
                525
            ]
        }, 
        "xmlC14NIsXmlAttr": {
            "code": "xmlC14NIsXmlAttr(xmlAttrPtr attr)\n(xmlC14NIsXmlNs(attr->ns) != 0));", 
            "lines": [
                865, 
                868
            ]
        }, 
        "xmlC14NIsNodeInNodeset": {
            "code": "xmlC14NIsNodeInNodeset(xmlNodeSetPtr nodes, xmlNodePtr node, xmlNodePtr parent) {\nif((nodes != NULL) && (node != NULL)) {\nif(node->type != XML_NAMESPACE_DECL) {\nreturn(xmlXPathNodeSetContains(nodes, node));\nxmlNs ns;\nif((parent != NULL) && (parent->type == XML_ATTRIBUTE_NODE)) {\nns.next = (xmlNsPtr)parent->parent;\nns.next = (xmlNsPtr)parent;\nreturn(xmlXPathNodeSetContains(nodes, (xmlNodePtr)&ns));\nreturn(1);", 
            "lines": [
                255, 
                256, 
                257, 
                258, 
                260, 
                265, 
                266, 
                268, 
                275, 
                278
            ]
        }, 
        "xmlC14NVisibleNsStackAdd": {
            "code": "xmlC14NVisibleNsStackAdd(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlNodePtr node) {\n((cur->nsTab == NULL) && (cur->nodeTab != NULL)) ||\n((cur->nsTab != NULL) && (cur->nodeTab == NULL))) {\nxmlC14NErrParam(\"adding namespace to stack\");\nif ((cur->nsTab == NULL) && (cur->nodeTab == NULL)) {\ncur->nsTab = (xmlNsPtr*) xmlMalloc(XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));\nif ((cur->nsTab == NULL) || (cur->nodeTab == NULL)) {\nxmlC14NErrMemory(\"adding node to stack\");\nmemset(cur->nsTab, 0 , XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));\n} else if(cur->nsMax == cur->nsCurEnd) {\nvoid *tmp;\nxmlC14NErrMemory(\"adding node to stack\");\ncur->nsTab = (xmlNsPtr*)tmp;\nxmlC14NErrMemory(\"adding node to stack\");\ncur->nodeTab = (xmlNodePtr*)tmp;\ncur->nsTab[cur->nsCurEnd] = ns;", 
            "lines": [
                314, 
                316, 
                317, 
                318, 
                322, 
                323, 
                325, 
                326, 
                329, 
                332, 
                333, 
                339, 
                342, 
                346, 
                349, 
                353
            ]
        }, 
        "xmlC14NPrintNamespaces": {
            "code": "xmlC14NPrintNamespaces(const xmlNsPtr ns, xmlC14NCtxPtr ctx)\nif ((ns == NULL) || (ctx == NULL)) {\nxmlC14NErrParam(\"writing namespaces\");\nif (ns->prefix != NULL) {\nxmlOutputBufferWriteString(ctx->buf, \" xmlns:\");\nxmlOutputBufferWriteString(ctx->buf, \" xmlns=\");\nif(ns->href != NULL) {\nxmlBufWriteQuotedString(ctx->buf->buffer, ns->href);\nxmlOutputBufferWriteString(ctx->buf, \"\\\"\\\"\");\nreturn (1);", 
            "lines": [
                539, 
                542, 
                543, 
                547, 
                548, 
                552, 
                554, 
                555, 
                557, 
                559
            ]
        }, 
        "xmlC14NPrintAttrs": {
            "code": "xmlC14NPrintAttrs(const xmlAttrPtr attr, xmlC14NCtxPtr ctx)\nif ((attr == NULL) || (ctx == NULL)) {\nxmlC14NErrParam(\"writing attributes\");\nxmlOutputBufferWriteString(ctx->buf, \" \");\nif (attr->ns != NULL && xmlStrlen(attr->ns->prefix) > 0) {\nxmlOutputBufferWriteString(ctx->buf,\nxmlOutputBufferWriteString(ctx->buf, (const char *) attr->name);\nbuffer = xmlC11NNormalizeAttr(value);\nxmlOutputBufferWriteString(ctx->buf, (const char *) buffer);\nxmlC14NErrInternal(\"normalizing attributes axis\");\n}\nxmlOutputBufferWriteString(ctx->buf, \"\\\"\");", 
            "lines": [
                934, 
                939, 
                940, 
                944, 
                945, 
                946, 
                950, 
                956, 
                959, 
                962, 
                965, 
                966
            ]
        }, 
        "xmlC14NDocSave": {
            "code": "xmlC14NDocSave(xmlDocPtr doc, xmlNodeSetPtr nodes,\nxmlC14NErrParam(\"saving doc\");\nif (compression < 0)\ncompression = xmlGetCompressMode();\nbuf = xmlOutputBufferCreateFilename(filename, NULL, compression);\nxmlC14NErrInternal(\"creating temporary filename\");\nret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,\nxmlC14NErrInternal(\"cannicanize document to buffer\");\nret = xmlOutputBufferClose(buf);", 
            "lines": [
                2076, 
                2084, 
                2088, 
                2089, 
                2095, 
                2097, 
                2104, 
                2107, 
                2115
            ]
        }
    }, 
    "pattern.c": {
        "xmlPatternAdd": {
            "code": "xmlPatternAdd(xmlPatParserContextPtr ctxt ATTRIBUTE_UNUSED,\nxmlStepOpPtr temp;\nreturn (-1);\ncomp->steps = temp;\ncomp->steps[comp->nbStep].op = op;", 
            "lines": [
                347, 
                352, 
                358, 
                360, 
                363
            ]
        }, 
        "xmlCompilePathPattern": {
            "code": "xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\nif (CUR == '/') {\nctxt->comp->flags |= PAT_FROM_ROOT;\n} else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {\nctxt->comp->flags |= PAT_FROM_CUR;\nif ((CUR == '/') && (NXT(1) == '/')) {\nPUSH(XML_OP_ANCESTOR, NULL, NULL);\nNEXT;\nNEXT;\n} else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {\nPUSH(XML_OP_ANCESTOR, NULL, NULL);\nNEXT;\nNEXT;\nNEXT;\nSKIP_BLANKS;\nif (CUR == 0) {\nctxt->error = 1;\n}\nif (CUR == '@') {\nNEXT;\nSKIP_BLANKS;\nif (CUR != 0) {\nxmlCompileStepPattern(ctxt);\ngoto error;\n}\n} else {\nif (CUR == '/') {\nPUSH(XML_OP_ROOT, NULL, NULL);\nNEXT;\nSKIP_BLANKS;\nif (CUR == 0) {\nctxt->error = 1;\n}\nxmlCompileStepPattern(ctxt);\ngoto error;\nSKIP_BLANKS;\nwhile (CUR == '/') {\nif (NXT(1) == '/') {\nPUSH(XML_OP_ANCESTOR, NULL, NULL);\nNEXT;\nNEXT;\nSKIP_BLANKS;\nxmlCompileStepPattern(ctxt);\ngoto error;\n} else {\nPUSH(XML_OP_PARENT, NULL, NULL);\nNEXT;\nSKIP_BLANKS;\nif (CUR == 0) {\nctxt->error = 1;\nxmlCompileStepPattern(ctxt);\ngoto error;\nif (CUR != 0) {\nctxt->error = 1;", 
            "lines": [
                1232, 
                1233, 
                1234, 
                1235, 
                1236, 
                1237, 
                1240, 
                1241, 
                1242, 
                1243, 
                1244, 
                1245, 
                1246, 
                1247, 
                1248, 
                1250, 
                1251, 
                1254, 
                1257, 
                1258, 
                1259, 
                1261, 
                1263, 
                1264, 
                1266, 
                1267, 
                1268, 
                1269, 
                1270, 
                1271, 
                1273, 
                1274, 
                1277, 
                1280, 
                1281, 
                1283, 
                1284, 
                1285, 
                1286, 
                1287, 
                1288, 
                1289, 
                1290, 
                1291, 
                1293, 
                1294, 
                1295, 
                1296, 
                1297, 
                1298, 
                1301, 
                1304, 
                1306, 
                1310, 
                1313
            ]
        }, 
        "xmlPatternFromRoot": {
            "code": "xmlPatternFromRoot(xmlPatternPtr comp) {\nreturn(-1);\nwhile (comp != NULL) {\nif (comp->stream == NULL)\nreturn(-1);\nif (comp->flags & PAT_FROM_ROOT)\nreturn(1);\ncomp = comp->next;\nreturn(0);", 
            "lines": [
                2601, 
                2603, 
                2604, 
                2605, 
                2606, 
                2607, 
                2608, 
                2609, 
                2611
            ]
        }, 
        "xmlCompileIDCXPathPath": {
            "code": "xmlCompileIDCXPathPath(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\nif (CUR == '/') {\ngoto error;\nctxt->comp->flags |= PAT_FROM_CUR;\nNEXT;\nSKIP_BLANKS;\nif (CUR == 0) {\nPUSH(XML_OP_ELEM, NULL, NULL);\nreturn;\nif (CUR != '/') {\ngoto error;\nNEXT;\nSKIP_BLANKS;\nif (CUR == '/') {\nif (IS_BLANK_CH(PEEKPREV(1))) {\ngoto error;\nPUSH(XML_OP_ANCESTOR, NULL, NULL);\nNEXT;\nSKIP_BLANKS;\n}\nif (CUR == 0)\ngoto error_unfinished;\n}\ndo {\nxmlCompileStepPattern(ctxt);\ngoto error;\nSKIP_BLANKS;\nif (CUR != '/')\nbreak;\nPUSH(XML_OP_PARENT, NULL, NULL);\nNEXT;\nSKIP_BLANKS;\nif (CUR == '/') {\ngoto error;\nif (CUR == 0)\ngoto error_unfinished;\n} while (CUR != 0);\nif (CUR != 0) {\nctxt->error = 1;\nreturn;\nctxt->error = 1;\nctxt->error = 1;", 
            "lines": [
                1329, 
                1330, 
                1331, 
                1335, 
                1337, 
                1341, 
                1342, 
                1343, 
                1347, 
                1348, 
                1350, 
                1354, 
                1357, 
                1358, 
                1359, 
                1360, 
                1366, 
                1369, 
                1370, 
                1371, 
                1372, 
                1373, 
                1374, 
                1375, 
                1379, 
                1380, 
                1382, 
                1383, 
                1384, 
                1385, 
                1386, 
                1387, 
                1388, 
                1389, 
                1396, 
                1398, 
                1399, 
                1401, 
                1403, 
                1406, 
                1408, 
                1410, 
                1414
            ]
        }, 
        "xmlPatScanName": {
            "code": "xmlPatScanName(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\ncur = q = CUR_PTR;\nif (!IS_LETTER(val) && (val != '_') && (val != ':'))\nreturn(NULL);\nwhile ((IS_LETTER(val)) || (IS_DIGIT(val)) ||\n(val == '.') || (val == '-') ||\n(val == '_') ||\n(IS_COMBINING(val)) ||\n(IS_EXTENDER(val))) {\ncur += len;\nif (ctxt->dict)\nret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\nret = xmlStrndup(q, cur - q);\nCUR_PTR = cur;", 
            "lines": [
                822, 
                827, 
                829, 
                831, 
                832, 
                834, 
                835, 
                836, 
                837, 
                838, 
                839, 
                842, 
                843, 
                845, 
                846
            ]
        }, 
        "xmlStreamCompAddStep": {
            "code": "xmlStreamCompAddStep(xmlStreamCompPtr comp, const xmlChar *name,\ncur = (xmlStreamStepPtr) xmlRealloc(comp->steps,\nreturn(-1);\ncomp->steps = cur;\ncur = &comp->steps[comp->nbStep++];", 
            "lines": [
                1545, 
                1550, 
                1555, 
                1557, 
                1560
            ]
        }, 
        "xmlStreamCtxtAddState": {
            "code": "xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {\nfor (i = 0;i < comp->nbState;i++) {\nif (comp->states[2 * i] < 0) {\ncomp->states[2 * i] = idx;\n}\nif (comp->nbState >= comp->maxState) {\nint *cur;\nreturn(-1);\ncomp->states = cur;\ncomp->states[2 * comp->nbState] = idx;", 
            "lines": [
                1813, 
                1815, 
                1816, 
                1817, 
                1821, 
                1822, 
                1823, 
                1830, 
                1832, 
                1835
            ]
        }, 
        "xmlFreePatParserContext": {
            "code": "xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {\nreturn;\nmemset(ctxt, -1, sizeof(xmlPatParserContext));", 
            "lines": [
                328, 
                330, 
                331
            ]
        }, 
        "xmlPatterncompile": {
            "code": "xmlPatterncompile(const xmlChar *pattern, xmlDict *dict, int flags,\nreturn(NULL);\nstart = pattern;\nwhile (*or != 0) {\ntmp = NULL;\nwhile ((*or != 0) && (*or != '|')) or++;\nif (*or == 0)\nctxt = xmlNewPatParserContext(start, dict, namespaces);\ntmp = xmlStrndup(start, or - start);\nctxt = xmlNewPatParserContext(tmp, dict, namespaces);\nor++;\nif (ctxt == NULL) goto error;\ncur = xmlNewPattern();\nif (cur == NULL) goto error;\nif (dict) {\ncur->dict = dict;\nif (ret == NULL)\nret = cur;\ncur->next = ret->next;\ncur->flags = flags;\nxmlCompileIDCXPathPath(ctxt);\nxmlCompilePathPattern(ctxt);\nif (ctxt->error != 0)\ngoto error;\nxmlFreePatParserContext(ctxt);\nif (type == 0) {\ntype = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);\n} else if (type == PAT_FROM_ROOT) {\nif (cur->flags & PAT_FROM_CUR)\nstreamable = 0;\n} else if (type == PAT_FROM_CUR) {\nif (cur->flags & PAT_FROM_ROOT)\nstreamable = 0;\n}\n}\nif (streamable)\nxmlStreamCompile(cur);\nif (xmlReversePattern(cur) < 0)\ngoto error;\nif (tmp != NULL) {\nxmlFree(tmp);\nstart = or;\nif (streamable == 0) {\ncur = ret;\nwhile (cur != NULL) {\nif (cur->stream != NULL) {\nxmlFreeStreamComp(cur->stream);\ncur = cur->next;\n}\nreturn(ret);\nif (ctxt != NULL) xmlFreePatParserContext(ctxt);\nif (ret != NULL) xmlFreePattern(ret);\nif (tmp != NULL) xmlFree(tmp);\nreturn(NULL);", 
            "lines": [
                2358, 
                2368, 
                2370, 
                2372, 
                2373, 
                2374, 
                2375, 
                2376, 
                2378, 
                2380, 
                2382, 
                2384, 
                2385, 
                2386, 
                2390, 
                2391, 
                2394, 
                2395, 
                2397, 
                2400, 
                2404, 
                2406, 
                2407, 
                2408, 
                2409, 
                2414, 
                2415, 
                2416, 
                2417, 
                2418, 
                2419, 
                2420, 
                2421, 
                2422, 
                2423, 
                2424, 
                2425, 
                2426, 
                2427, 
                2428, 
                2429, 
                2432, 
                2434, 
                2435, 
                2436, 
                2437, 
                2438, 
                2441, 
                2443, 
                2445, 
                2447, 
                2448, 
                2449, 
                2450
            ]
        }, 
        "xmlReversePattern": {
            "code": "xmlReversePattern(xmlPatternPtr comp) {\nif ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {\nfor (i = 0, j = 1;j < comp->nbStep;i++,j++) {\ncomp->steps[i].value = comp->steps[j].value;\ncomp->nbStep--;\nif (comp->nbStep >= comp->maxStep) {\nxmlStepOpPtr temp;\nreturn (-1);\ncomp->steps = temp;\ni = 0;\nwhile (j > i) {\nregister const xmlChar *tmp;\ncomp->steps[comp->nbStep].value = NULL;", 
            "lines": [
                408, 
                414, 
                415, 
                416, 
                420, 
                422, 
                423, 
                429, 
                431, 
                434, 
                436, 
                437, 
                451
            ]
        }, 
        "xmlFreePatternList": {
            "code": "xmlFreePatternList(xmlPatternPtr comp) {\nwhile (comp != NULL) {\ncur = comp;", 
            "lines": [
                269, 
                272, 
                273
            ]
        }, 
        "xmlNewStreamCtxt": {
            "code": "xmlNewStreamCtxt(xmlStreamCompPtr stream) {\nreturn(NULL);\nmemset(cur, 0, sizeof(xmlStreamCtxt));\nxmlFree(cur);\ncur->nbState = 0;", 
            "lines": [
                1759, 
                1766, 
                1768, 
                1771, 
                1776
            ]
        }, 
        "xmlPatternMatch": {
            "code": "xmlPatternMatch(xmlPatternPtr comp, xmlNodePtr node)\nif ((comp == NULL) || (node == NULL))\nreturn(-1);\nwhile (comp != NULL) {\nret = xmlPatMatch(comp, node);\nreturn(ret);\ncomp = comp->next;\nreturn(ret);", 
            "lines": [
                2463, 
                2467, 
                2468, 
                2470, 
                2471, 
                2473, 
                2474, 
                2476
            ]
        }, 
        "xmlStreamPop": {
            "code": "xmlStreamPop(xmlStreamCtxtPtr stream) {\nreturn(-1);\nwhile (stream != NULL) {\nif (stream->blockLevel == stream->level)\nstream->blockLevel = -1;\nif (stream->level)\nstream->level--;\nfor (i = stream->nbState -1; i >= 0; i--) {\nlev = stream->states[(2 * i) + 1];\nstream->nbState--;\nif (lev <= stream->level)\nbreak;\n}\nstream = stream->next;\nreturn(0);", 
            "lines": [
                2280, 
                2284, 
                2285, 
                2289, 
                2290, 
                2297, 
                2298, 
                2302, 
                2304, 
                2306, 
                2307, 
                2308, 
                2309, 
                2310, 
                2312
            ]
        }, 
        "xmlPatternMinDepth": {
            "code": "xmlPatternMinDepth(xmlPatternPtr comp) {\nreturn(-1);\nwhile (comp != NULL) {\nif (comp->stream == NULL)\nreturn(-1);\nif (comp->stream->nbStep < ret)\nret = comp->stream->nbStep;\nif (ret == 0)\nreturn(0);\ncomp = comp->next;\nreturn(ret);", 
            "lines": [
                2576, 
                2579, 
                2580, 
                2581, 
                2582, 
                2583, 
                2584, 
                2585, 
                2586, 
                2587, 
                2589
            ]
        }, 
        "xmlCompileStepPattern": {
            "code": "xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\nif (CUR == '.') {\nNEXT;\nPUSH(XML_OP_ELEM, NULL, NULL);\nreturn;\nif (CUR == '@') {\nif (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\nctxt->error = 1;\nNEXT;\ngoto error;\nreturn;\nname = xmlPatScanNCName(ctxt);\nif (CUR == '*') {\nNEXT;\nPUSH(XML_OP_ALL, NULL, NULL);\nreturn;\nctxt->error = 1;\nif (IS_BLANK_CH(CUR)) {\nhasBlanks = 1;\nSKIP_BLANKS;\n}\nif (CUR == ':') {\nNEXT;\nxmlChar *prefix = name;\nif (hasBlanks || IS_BLANK_CH(CUR)) {\nctxt->error = 1;\ntoken = xmlPatScanName(ctxt);\n(prefix[1] == 'm') &&\n(prefix[2] == 'l') &&\n(prefix[3] == 0))\nXML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n} else {\nfor (i = 0;i < ctxt->nb_namespaces;i++) {\nif (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\nXML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\nbreak;\n}\nif (i >= ctxt->nb_namespaces) {\nctxt->error = 1;\nXML_PAT_FREE_STRING(ctxt, prefix);\nname = NULL;\nif (CUR == '*') {\nNEXT;\nPUSH(XML_OP_NS, URL, NULL);\n} else {\nctxt->error = 1;\n} else {\nPUSH(XML_OP_ELEM, token, URL);\n} else {\nNEXT;\nXML_PAT_FREE_STRING(ctxt, name);\nname = xmlPatScanName(ctxt);\nif (CUR == '*') {\nNEXT;\nPUSH(XML_OP_ALL, NULL, NULL);\nreturn;\nctxt->error = 1;\nif (CUR == ':') {\nxmlChar *prefix = name;\nNEXT;\nif (IS_BLANK_CH(CUR)) {\nctxt->error = 1;\ntoken = xmlPatScanName(ctxt);\n(prefix[1] == 'm') &&\n(prefix[2] == 'l') &&\n(prefix[3] == 0))\nXML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n} else {\nfor (i = 0;i < ctxt->nb_namespaces;i++) {\nif (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\nXML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\nbreak;\n}\nif (i >= ctxt->nb_namespaces) {\nctxt->error = 1;\nXML_PAT_FREE_STRING(ctxt, prefix);\nname = NULL;\nif (CUR == '*') {\nNEXT;\nPUSH(XML_OP_NS, URL, NULL);\n} else {\nctxt->error = 1;\n} else {\nPUSH(XML_OP_CHILD, token, URL);\n} else\nPUSH(XML_OP_CHILD, name, NULL);\nreturn;\n} else if (xmlStrEqual(name, (const xmlChar *) \"attribute\")) {\nXML_PAT_FREE_STRING(ctxt, name)\nname = NULL;\nctxt->error = 1;\nxmlCompileAttributeTest(ctxt);\ngoto error;\nreturn;\nctxt->error = 1;\n} else if (CUR == '*') {\nif (name != NULL) {\nctxt->error = 1;\nNEXT;\nPUSH(XML_OP_ALL, token, NULL);\n} else {\nPUSH(XML_OP_ELEM, name, NULL);\nreturn;\nif (URL != NULL)\nXML_PAT_FREE_STRING(ctxt, URL)\nif (token != NULL)\nXML_PAT_FREE_STRING(ctxt, token)\nif (name != NULL)\nXML_PAT_FREE_STRING(ctxt, name)", 
            "lines": [
                1013, 
                1019, 
                1020, 
                1024, 
                1025, 
                1026, 
                1028, 
                1032, 
                1035, 
                1038, 
                1041, 
                1042, 
                1044, 
                1046, 
                1047, 
                1048, 
                1049, 
                1053, 
                1057, 
                1058, 
                1059, 
                1060, 
                1061, 
                1062, 
                1064, 
                1067, 
                1069, 
                1075, 
                1077, 
                1078, 
                1079, 
                1081, 
                1082, 
                1083, 
                1084, 
                1085, 
                1086, 
                1088, 
                1089, 
                1093, 
                1097, 
                1098, 
                1100, 
                1101, 
                1102, 
                1103, 
                1106, 
                1109, 
                1110, 
                1112, 
                1113, 
                1115, 
                1116, 
                1118, 
                1119, 
                1120, 
                1121, 
                1125, 
                1129, 
                1130, 
                1133, 
                1134, 
                1136, 
                1142, 
                1144, 
                1145, 
                1146, 
                1148, 
                1149, 
                1150, 
                1151, 
                1152, 
                1153, 
                1155, 
                1156, 
                1160, 
                1164, 
                1165, 
                1167, 
                1168, 
                1169, 
                1170, 
                1173, 
                1176, 
                1177, 
                1179, 
                1180, 
                1181, 
                1182, 
                1183, 
                1184, 
                1188, 
                1191, 
                1193, 
                1194, 
                1198, 
                1202, 
                1203, 
                1204, 
                1207, 
                1208, 
                1209, 
                1210, 
                1212, 
                1214, 
                1215, 
                1216, 
                1217, 
                1218, 
                1219
            ]
        }, 
        "xmlPatMatch": {
            "code": "xmlPatMatch(xmlPatternPtr comp, xmlNodePtr node) {\nif ((comp == NULL) || (node == NULL)) return(-1);\ni = 0;\nfor (;i < comp->nbStep;i++) {\nstep = &comp->steps[i];\ngoto found;\nif (node->type == XML_NAMESPACE_DECL)\ngoto rollback;\nnode = node->parent;\n(node->type == XML_DOCB_DOCUMENT_NODE) ||\n(node->type == XML_HTML_DOCUMENT_NODE))\ncontinue;\ngoto rollback;\nif (node->type != XML_ELEMENT_NODE)\ngoto rollback;\nif (step->value == NULL)\ncontinue;\nif (step->value[0] != node->name[0])\ngoto rollback;\nif (!xmlStrEqual(step->value, node->name))\ngoto rollback;\nif (node->ns == NULL) {\nif (step->value2 != NULL)\ngoto rollback;\n} else if (node->ns->href != NULL) {\nif (step->value2 == NULL)\ngoto rollback;\nif (!xmlStrEqual(step->value2, node->ns->href))\ngoto rollback;\n}\ncontinue;\nxmlNodePtr lst;\n(node->type != XML_DOCUMENT_NODE) &&\n(node->type != XML_DOCB_DOCUMENT_NODE) &&\n(node->type != XML_HTML_DOCUMENT_NODE))\ngoto rollback;\nlst = node->children;\nwhile (lst != NULL) {\nif ((lst->type == XML_ELEMENT_NODE) &&\n(step->value[0] == lst->name[0]) &&\n(xmlStrEqual(step->value, lst->name)))\nbreak;\nlst = lst->next;\nif (lst != NULL)\ncontinue;\n}\ngoto rollback;\nif (node->type != XML_ATTRIBUTE_NODE)\ngoto rollback;\nif (step->value != NULL) {\nif (step->value[0] != node->name[0])\ngoto rollback;\nif (!xmlStrEqual(step->value, node->name))\ngoto rollback;\n}\nif (node->ns == NULL) {\nif (step->value2 != NULL)\ngoto rollback;\n} else if (step->value2 != NULL) {\nif (!xmlStrEqual(step->value2, node->ns->href))\ngoto rollback;\n}\ncontinue;\nif ((node->type == XML_DOCUMENT_NODE) ||\n(node->type == XML_HTML_DOCUMENT_NODE) ||\n(node->type == XML_DOCB_DOCUMENT_NODE) ||\n(node->type == XML_NAMESPACE_DECL))\ngoto rollback;\nnode = node->parent;\ngoto rollback;\nif (step->value == NULL)\ncontinue;\nif (step->value[0] != node->name[0])\ngoto rollback;\nif (!xmlStrEqual(step->value, node->name))\ngoto rollback;\nif (node->ns == NULL) {\nif (step->value2 != NULL)\ngoto rollback;\n} else if (node->ns->href != NULL) {\nif (step->value2 == NULL)\ngoto rollback;\nif (!xmlStrEqual(step->value2, node->ns->href))\ngoto rollback;\n}\ncontinue;\nif (step->value == NULL) {\ni++;\ngoto found;\nif (step->op != XML_OP_ELEM)\ngoto rollback;\nif (step->value == NULL)\nreturn(-1);\n}\nif (node == NULL)\ngoto rollback;\nif ((node->type == XML_DOCUMENT_NODE) ||\n(node->type == XML_HTML_DOCUMENT_NODE) ||\n(node->type == XML_DOCB_DOCUMENT_NODE) ||\n(node->type == XML_NAMESPACE_DECL))\ngoto rollback;\nnode = node->parent;\nwhile (node != NULL) {\nif ((node->type == XML_ELEMENT_NODE) &&\n(step->value[0] == node->name[0]) &&\n(xmlStrEqual(step->value, node->name))) {\nif (node->ns == NULL) {\nif (step->value2 == NULL)\nbreak;\n} else if (node->ns->href != NULL) {\nif ((step->value2 != NULL) &&\n(xmlStrEqual(step->value2, node->ns->href)))\nbreak;\n}\n}\nnode = node->parent;\nif (node == NULL)\ngoto rollback;\nif (step->op == XML_OP_ANCESTOR)\nxmlPatPushState(&states, i, node);\nxmlPatPushState(&states, i - 1, node);\ncontinue;\nif (node->type != XML_ELEMENT_NODE)\ngoto rollback;\nif (node->ns == NULL) {\nif (step->value != NULL)\ngoto rollback;\n} else if (node->ns->href != NULL) {\nif (step->value == NULL)\ngoto rollback;\nif (!xmlStrEqual(step->value, node->ns->href))\ngoto rollback;\n}\nbreak;\nif (node->type != XML_ELEMENT_NODE)\ngoto rollback;\nbreak;\n}\nif (states.states != NULL) {\nxmlFree(states.states);\nreturn(1);\nif (states.states == NULL)\nreturn(0);\nif (states.nbstates <= 0) {\nxmlFree(states.states);\nstates.nbstates--;", 
            "lines": [
                498, 
                503, 
                504, 
                506, 
                507, 
                510, 
                512, 
                513, 
                514, 
                517, 
                519, 
                520, 
                521, 
                523, 
                524, 
                525, 
                526, 
                527, 
                528, 
                529, 
                530, 
                533, 
                534, 
                535, 
                536, 
                537, 
                538, 
                539, 
                540, 
                541, 
                542, 
                544, 
                547, 
                549, 
                551, 
                552, 
                554, 
                557, 
                558, 
                559, 
                560, 
                561, 
                562, 
                564, 
                565, 
                566, 
                567, 
                570, 
                571, 
                572, 
                573, 
                574, 
                575, 
                576, 
                577, 
                579, 
                580, 
                581, 
                582, 
                583, 
                584, 
                585, 
                586, 
                588, 
                589, 
                591, 
                593, 
                594, 
                595, 
                597, 
                598, 
                599, 
                600, 
                601, 
                602, 
                603, 
                605, 
                606, 
                607, 
                608, 
                609, 
                610, 
                611, 
                612, 
                613, 
                614, 
                617, 
                618, 
                621, 
                622, 
                623, 
                624, 
                625, 
                626, 
                627, 
                628, 
                629, 
                630, 
                632, 
                634, 
                635, 
                636, 
                637, 
                638, 
                639, 
                640, 
                642, 
                643, 
                644, 
                645, 
                646, 
                647, 
                648, 
                649, 
                650, 
                651, 
                653, 
                654, 
                659, 
                660, 
                662, 
                663, 
                665, 
                666, 
                667, 
                668, 
                669, 
                670, 
                671, 
                672, 
                673, 
                674, 
                675, 
                676, 
                678, 
                679, 
                680, 
                682, 
                684, 
                686, 
                688, 
                691, 
                692, 
                693, 
                694, 
                697
            ]
        }, 
        "xmlStreamWantsAnyNode": {
            "code": "xmlStreamWantsAnyNode(xmlStreamCtxtPtr streamCtxt)\nreturn(-1);\nwhile (streamCtxt != NULL) {\nif (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)\nreturn(1);\nstreamCtxt = streamCtxt->next;\nreturn(0);", 
            "lines": [
                2328, 
                2331, 
                2332, 
                2333, 
                2334, 
                2335, 
                2337
            ]
        }, 
        "xmlPatternGetStreamCtxt": {
            "code": "xmlPatternGetStreamCtxt(xmlPatternPtr comp)\nif ((comp == NULL) || (comp->stream == NULL))\nreturn(NULL);\nwhile (comp != NULL) {\nif (comp->stream == NULL)\ngoto failed;\ncur = xmlNewStreamCtxt(comp->stream);\ngoto failed;\nif (ret == NULL)\nret = cur;\ncur->next = ret->next;\ncur->flags = comp->flags;\nreturn(ret);\nxmlFreeStreamCtxt(ret);", 
            "lines": [
                2489, 
                2493, 
                2494, 
                2496, 
                2497, 
                2498, 
                2499, 
                2501, 
                2502, 
                2503, 
                2505, 
                2508, 
                2511, 
                2513
            ]
        }, 
        "xmlStreamCompile": {
            "code": "xmlStreamCompile(xmlPatternPtr comp) {\nif ((comp == NULL) || (comp->steps == NULL))\nreturn(-1);\nif ((comp->nbStep == 1) &&\n(comp->steps[0].op == XML_OP_ELEM) &&\n(comp->steps[0].value == NULL) &&\n(comp->steps[0].value2 == NULL)) {\nstream = xmlNewStreamComp(0);\nreturn(-1);\nstream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\nstream = xmlNewStreamComp((comp->nbStep / 2) + 1);\nreturn(-1);\nif (comp->dict != NULL) {\nstream->dict = comp->dict;\ni = 0;\nstream->flags |= XML_STREAM_FROM_ROOT;\nfor (;i < comp->nbStep;i++) {\nstep = comp->steps[i];\nbreak;\nif (i != 0)\ngoto error;\nroot = 1;\ns = xmlStreamCompAddStep(stream, NULL, step.value,\ngoto error;\nprevs = s;\nflags |= XML_STREAM_STEP_ATTR;\ngoto error;\nbreak;\nif ((step.value == NULL) && (step.value2 == NULL)) {\nif ((comp->nbStep == i + 1) &&\n(flags & XML_STREAM_STEP_DESC)) {\nif (comp->nbStep == i + 1) {\nstream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\nflags |= XML_STREAM_STEP_NODE;\ngoto error;\nflags = 0;\nstream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;\nbreak;\ncontinue;\ns = xmlStreamCompAddStep(stream, step.value, step.value2,\ngoto error;\nprevs = s;\ns = xmlStreamCompAddStep(stream, step.value, step.value2,\ngoto error;\nprevs = s;\ns = xmlStreamCompAddStep(stream, NULL, NULL,\ngoto error;\nprevs = s;\nbreak;\nif (flags & XML_STREAM_STEP_DESC)\nbreak;\nflags |= XML_STREAM_STEP_DESC;\nstream->flags |= XML_STREAM_DESC;\nbreak;\n}\nif ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {\nif ((stream->flags & XML_STREAM_DESC) == 0)\nstream->flags |= XML_STREAM_DESC;\nif (stream->nbStep > 0) {\nif ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)\nstream->steps[0].flags |= XML_STREAM_STEP_DESC;\n}\n}\nif (stream->nbStep <= s)\ngoto error;\nstream->steps[s].flags |= XML_STREAM_STEP_FINAL;\nstream->steps[0].flags |= XML_STREAM_STEP_ROOT;\ncomp->stream = stream;\nxmlFreeStreamComp(stream);", 
            "lines": [
                1577, 
                1582, 
                1583, 
                1587, 
                1588, 
                1589, 
                1590, 
                1591, 
                1593, 
                1595, 
                1600, 
                1602, 
                1603, 
                1604, 
                1608, 
                1610, 
                1612, 
                1613, 
                1616, 
                1618, 
                1619, 
                1620, 
                1623, 
                1626, 
                1627, 
                1631, 
                1637, 
                1638, 
                1640, 
                1649, 
                1650, 
                1655, 
                1656, 
                1658, 
                1662, 
                1663, 
                1671, 
                1674, 
                1678, 
                1682, 
                1685, 
                1686, 
                1691, 
                1694, 
                1695, 
                1699, 
                1702, 
                1703, 
                1707, 
                1710, 
                1711, 
                1712, 
                1717, 
                1718, 
                1720, 
                1721, 
                1727, 
                1728, 
                1730, 
                1731, 
                1732, 
                1733, 
                1734, 
                1735, 
                1736, 
                1737, 
                1739, 
                1743, 
                1746
            ]
        }, 
        "xmlPatternMaxDepth": {
            "code": "xmlPatternMaxDepth(xmlPatternPtr comp) {\nreturn(-1);\nwhile (comp != NULL) {\nif (comp->stream == NULL)\nreturn(-1);\nfor (i = 0;i < comp->stream->nbStep;i++)\nif (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)\nreturn(-2);\nif (comp->stream->nbStep > ret)\nret = comp->stream->nbStep;\ncomp = comp->next;\nreturn(ret);", 
            "lines": [
                2548, 
                2551, 
                2552, 
                2553, 
                2554, 
                2555, 
                2556, 
                2557, 
                2558, 
                2559, 
                2560, 
                2562
            ]
        }, 
        "xmlStreamPushInternal": {
            "code": "xmlStreamPushInternal(xmlStreamCtxtPtr stream,\nif ((stream == NULL) || (stream->nbState < 0))\nreturn(-1);\nwhile (stream != NULL) {\ncomp = stream->comp;\n(name == NULL) && (ns == NULL)) {\nstream->nbState = 0;\nif (comp->nbStep == 0) {\nret = 1;\nif ((comp->nbStep == 1) &&\n(comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&\n(comp->steps[0].flags & XML_STREAM_STEP_DESC))\nret = 1;\n} else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {\ntmp = xmlStreamCtxtAddState(stream, 0, 0);\nerr++;\n}\n}\nstream = stream->next;\nif (comp->nbStep == 0) {\nif (stream->flags & XML_PATTERN_XPATH) {\nstream = stream->next;\nif ((nodeType != XML_ATTRIBUTE_NODE) &&\n(((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||\n(stream->level == 0))) {\nret = 1;\nstream->level++;\nif (stream->blockLevel != -1) {\nstream->level++;\nif ((nodeType != XML_ELEMENT_NODE) &&\n(nodeType != XML_ATTRIBUTE_NODE) &&\n((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {\nstream->level++;\ni = 0;\nwhile (i < m) {\nif ((comp->flags & XML_STREAM_DESC) == 0) {\nstepNr = stream->states[2 * (stream->nbState -1)];\nreturn (-1);\ndesc = 0;\nstepNr = stream->states[2 * i];\ngoto next_state;\ntmp = stream->states[(2 * i) + 1];\ngoto next_state;\ndesc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;\nif ((tmp < stream->level) && (!desc))\ngoto next_state;\nstep = comp->steps[stepNr];\nif (step.nodeType == XML_ATTRIBUTE_NODE) {\nif ((comp->flags & XML_STREAM_DESC) == 0)\nstream->blockLevel = stream->level +1;\ngoto next_state;\n} else if (step.nodeType != XML_STREAM_ANY_NODE)\ngoto next_state;\n}\nmatch = 0;\nmatch = 1;\n} else if (step.name == NULL) {\nif (step.ns == NULL) {\nmatch = 1;\n} else if (ns != NULL)\nmatch = xmlStrEqual(step.ns, ns);\n} else if (((step.ns != NULL) == (ns != NULL)) &&\n(name != NULL) &&\n(step.name[0] == name[0]) &&\nxmlStrEqual(step.name, name) &&\n((step.ns == ns) || xmlStrEqual(step.ns, ns)))\nmatch = 1;\nif (match) {\nfinal = step.flags & XML_STREAM_STEP_FINAL;\nif (final) {\nret = 1;\nxmlStreamCtxtAddState(stream, stepNr + 1,\n} else {\nif (final) {\nret = 1;\nxmlStreamCtxtAddState(stream, stepNr + 1,\nif ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\nret = 1;\n}\nif (((comp->flags & XML_STREAM_DESC) == 0) &&\n((! match) || final))  {\nstream->blockLevel = stream->level +1;\ni++;\nstream->level++;\ngoto stream_next;\ndesc = step.flags & XML_STREAM_STEP_DESC;\nif (stream->flags & XML_PATTERN_NOTPATTERN) {\nif (stream->level == 1) {\nif (XML_STREAM_XS_IDC(stream)) {\ngoto stream_next;\ngoto compare;\nif (desc)\ngoto compare;\nif ((stream->level == 2) && XML_STREAM_XS_IDC(stream))\ngoto compare;\ngoto stream_next;\nif (step.nodeType != nodeType) {\nif (nodeType == XML_ATTRIBUTE_NODE)\ngoto stream_next;\nelse if (step.nodeType != XML_STREAM_ANY_NODE)\ngoto stream_next;\n}\nmatch = 0;\nmatch = 1;\n} else if (step.name == NULL) {\nif (step.ns == NULL) {\nmatch = 1;\n} else if (ns != NULL)\nmatch = xmlStrEqual(step.ns, ns);\n} else if (((step.ns != NULL) == (ns != NULL)) &&\n(name != NULL) &&\n(step.name[0] == name[0]) &&\nxmlStrEqual(step.name, name) &&\n((step.ns == ns) || xmlStrEqual(step.ns, ns)))\nmatch = 1;\nfinal = step.flags & XML_STREAM_STEP_FINAL;\nif (final)\nret = 1;\nxmlStreamCtxtAddState(stream, 1, stream->level);\nif ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\nret = 1;\n}\nif (((comp->flags & XML_STREAM_DESC) == 0) &&\n((! match) || final))  {\nstream->blockLevel = stream->level;\nstream = stream->next;\nif (err > 0)\nret = -1;\nreturn(ret);", 
            "lines": [
                1857, 
                1867, 
                1868, 
                1870, 
                1871, 
                1874, 
                1876, 
                1880, 
                1882, 
                1884, 
                1885, 
                1886, 
                1892, 
                1893, 
                1895, 
                1897, 
                1898, 
                1900, 
                1901, 
                1908, 
                1913, 
                1914, 
                1922, 
                1923, 
                1924, 
                1925, 
                1927, 
                1930, 
                1934, 
                1938, 
                1939, 
                1940, 
                1946, 
                1953, 
                1955, 
                1956, 
                1961, 
                1967, 
                1969, 
                1978, 
                1982, 
                1984, 
                1988, 
                1991, 
                1992, 
                1993, 
                1998, 
                2000, 
                2004, 
                2005, 
                2006, 
                2007, 
                2008, 
                2009, 
                2013, 
                2015, 
                2016, 
                2017, 
                2021, 
                2022, 
                2023, 
                2024, 
                2025, 
                2026, 
                2027, 
                2028, 
                2030, 
                2048, 
                2049, 
                2051, 
                2052, 
                2055, 
                2058, 
                2059, 
                2060, 
                2062, 
                2066, 
                2071, 
                2073, 
                2074, 
                2075, 
                2081, 
                2084, 
                2087, 
                2096, 
                2098, 
                2099, 
                2105, 
                2106, 
                2111, 
                2113, 
                2118, 
                2119, 
                2126, 
                2127, 
                2129, 
                2136, 
                2137, 
                2138, 
                2139, 
                2140, 
                2141, 
                2145, 
                2147, 
                2148, 
                2149, 
                2153, 
                2154, 
                2155, 
                2156, 
                2157, 
                2158, 
                2159, 
                2160, 
                2162, 
                2164, 
                2166, 
                2167, 
                2169, 
                2170, 
                2175, 
                2177, 
                2178, 
                2179, 
                2184, 
                2188, 
                2191, 
                2192, 
                2196
            ]
        }, 
        "xmlNewStreamComp": {
            "code": "xmlNewStreamComp(int size) {\nsize  = 4;\ncur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));\nreturn(NULL);\nmemset(cur, 0, sizeof(xmlStreamComp));\nxmlFree(cur);\ncur->nbStep = 0;", 
            "lines": [
                1491, 
                1495, 
                1497, 
                1501, 
                1503, 
                1506, 
                1511
            ]
        }, 
        "xmlFreePattern": {
            "code": "xmlFreePattern(xmlPatternPtr comp) {\nreturn;\nif (comp->next != NULL)\nxmlFreePattern(comp->next);\nif (comp->stream != NULL)\nxmlFreeStreamComp(comp->stream);\nif (comp->pattern != NULL)\nxmlFree((xmlChar *)comp->pattern);\nif (comp->steps != NULL) {\nif (comp->dict == NULL) {\nfor (i = 0;i < comp->nbStep;i++) {\nop = &comp->steps[i];\nxmlFree((xmlChar *) op->value);\nif (op->value2 != NULL)\nxmlFree((xmlChar *) op->value2);\n}\n}\nxmlFree(comp->steps);\nif (comp->dict != NULL)\nxmlDictFree(comp->dict);\nmemset(comp, -1, sizeof(xmlPattern));", 
            "lines": [
                231, 
                236, 
                237, 
                238, 
                239, 
                240, 
                241, 
                242, 
                243, 
                244, 
                245, 
                246, 
                248, 
                249, 
                250, 
                251, 
                252, 
                253, 
                255, 
                256, 
                258
            ]
        }, 
        "xmlFreeStreamCtxt": {
            "code": "xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {\nwhile (stream != NULL) {\nnext = stream->next;\nxmlFree(stream->states);\nxmlFree(stream);", 
            "lines": [
                1791, 
                1794, 
                1795, 
                1797, 
                1798
            ]
        }, 
        "xmlNewPatParserContext": {
            "code": "xmlNewPatParserContext(const xmlChar *pattern, xmlDictPtr dict,\nreturn(NULL);\ncur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));\nreturn(NULL);\nmemset(cur, 0, sizeof(xmlPatParserContext));\nint i;\nfor (i = 0;namespaces[2 * i] != NULL;i++)\ncur->nb_namespaces = i;\ncur->nb_namespaces = 0;\ncur->namespaces = namespaces;", 
            "lines": [
                292, 
                297, 
                299, 
                303, 
                305, 
                310, 
                311, 
                313, 
                315, 
                317
            ]
        }, 
        "xmlFreeStreamComp": {
            "code": "xmlFreeStreamComp(xmlStreamCompPtr comp) {\nif (comp->steps != NULL)\nxmlFree(comp->steps);\nif (comp->dict != NULL)\nxmlDictFree(comp->dict);\nxmlFree(comp);", 
            "lines": [
                1523, 
                1525, 
                1526, 
                1527, 
                1528, 
                1529
            ]
        }, 
        "xmlPatternStreamable": {
            "code": "xmlPatternStreamable(xmlPatternPtr comp) {\nreturn(-1);\nwhile (comp != NULL) {\nif (comp->stream == NULL)\nreturn(0);\ncomp = comp->next;\nreturn(1);", 
            "lines": [
                2527, 
                2529, 
                2530, 
                2531, 
                2532, 
                2533, 
                2535
            ]
        }, 
        "xmlPatScanNCName": {
            "code": "xmlPatScanNCName(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\ncur = q = CUR_PTR;\nif (!IS_LETTER(val) && (val != '_'))\nreturn(NULL);\nwhile ((IS_LETTER(val)) || (IS_DIGIT(val)) ||\n(val == '.') || (val == '-') ||\n(val == '_') ||\n(IS_COMBINING(val)) ||\n(IS_EXTENDER(val))) {\ncur += len;\nif (ctxt->dict)\nret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\nret = xmlStrndup(q, cur - q);\nCUR_PTR = cur;", 
            "lines": [
                860, 
                865, 
                867, 
                869, 
                870, 
                872, 
                873, 
                874, 
                875, 
                876, 
                877, 
                880, 
                881, 
                883, 
                884
            ]
        }, 
        "xmlPatPushState": {
            "code": "xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {\nif ((states->states == NULL) || (states->maxstates <= 0)) {\nstates->maxstates = 4;\nelse if (states->maxstates <= states->nbstates) {\nxmlStepState *tmp;\nreturn(-1);\nstates->states = tmp;\nstates->states[states->nbstates].step = step;", 
            "lines": [
                464, 
                465, 
                466, 
                470, 
                471, 
                476, 
                477, 
                480
            ]
        }, 
        "xmlCompileAttributeTest": {
            "code": "xmlCompileAttributeTest(xmlPatParserContextPtr ctxt) {\nSKIP_BLANKS;\nname = xmlPatScanNCName(ctxt);\nif (CUR == '*') {\nPUSH(XML_OP_ATTR, NULL, NULL);\nNEXT;\nctxt->error = 1;\nreturn;\nif (CUR == ':') {\nint i;\nNEXT;\nif (IS_BLANK_CH(CUR)) {\nXML_PAT_FREE_STRING(ctxt, prefix);\nctxt->error = 1;\ntoken = xmlPatScanName(ctxt);\n(prefix[1] == 'm') &&\n(prefix[2] == 'l') &&\n(prefix[3] == 0))\nXML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);\n} else {\nfor (i = 0;i < ctxt->nb_namespaces;i++) {\nif (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\nXML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\nbreak;\n}\nif (i >= ctxt->nb_namespaces) {\nctxt->error = 1;\nXML_PAT_FREE_STRING(ctxt, prefix);\nif (token == NULL) {\nif (CUR == '*') {\nNEXT;\nPUSH(XML_OP_ATTR, NULL, URL);\n} else {\nctxt->error = 1;\n} else {\nPUSH(XML_OP_ATTR, token, URL);\n} else {\nPUSH(XML_OP_ATTR, name, NULL);\nreturn;\nif (URL != NULL)\nXML_PAT_FREE_STRING(ctxt, URL)\nif (token != NULL)\nXML_PAT_FREE_STRING(ctxt, token);", 
            "lines": [
                921, 
                926, 
                927, 
                929, 
                930, 
                931, 
                935, 
                937, 
                939, 
                940, 
                943, 
                945, 
                947, 
                948, 
                954, 
                956, 
                957, 
                958, 
                960, 
                961, 
                962, 
                963, 
                964, 
                965, 
                967, 
                968, 
                972, 
                976, 
                977, 
                978, 
                979, 
                980, 
                981, 
                984, 
                987, 
                988, 
                990, 
                991, 
                993, 
                995, 
                996, 
                997, 
                998
            ]
        }, 
        "xmlNewPattern": {
            "code": "xmlPatternPtr cur;\nreturn(NULL);\nmemset(cur, 0, sizeof(xmlPattern));\nxmlFree(cur);\nreturn(cur);", 
            "lines": [
                204, 
                210, 
                212, 
                216, 
                221
            ]
        }
    }

}